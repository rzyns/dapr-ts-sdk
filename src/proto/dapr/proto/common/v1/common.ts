// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.180.0
//   protoc               v3.19.1
// source: dapr/proto/common/v1/common.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";
import { Any } from "../../../../google/protobuf/any.js";

export const protobufPackage = "dapr.proto.common.v1";

/**
 * HTTPExtension includes HTTP verb and querystring
 * when Dapr runtime delivers HTTP content.
 *
 * For example, when callers calls http invoke api
 * POST http://localhost:3500/v1.0/invoke/<app_id>/method/<method>?query1=value1&query2=value2
 *
 * Dapr runtime will parse POST as a verb and extract querystring to quersytring map.
 */
export interface HTTPExtension {
  /** Required. HTTP verb. */
  verb: HTTPExtension_Verb;
  /** Optional. querystring represents an encoded HTTP url query string in the following format: name=value&name2=value2 */
  querystring: string;
}

/**
 * Type of HTTP 1.1 Methods
 * RFC 7231: https://tools.ietf.org/html/rfc7231#page-24
 * RFC 5789: https://datatracker.ietf.org/doc/html/rfc5789
 */
export enum HTTPExtension_Verb {
  NONE = 0,
  GET = 1,
  HEAD = 2,
  POST = 3,
  PUT = 4,
  DELETE = 5,
  CONNECT = 6,
  OPTIONS = 7,
  TRACE = 8,
  PATCH = 9,
  UNRECOGNIZED = -1,
}

export function hTTPExtension_VerbFromJSON(object: any): HTTPExtension_Verb {
  switch (object) {
    case 0:
    case "NONE":
      return HTTPExtension_Verb.NONE;
    case 1:
    case "GET":
      return HTTPExtension_Verb.GET;
    case 2:
    case "HEAD":
      return HTTPExtension_Verb.HEAD;
    case 3:
    case "POST":
      return HTTPExtension_Verb.POST;
    case 4:
    case "PUT":
      return HTTPExtension_Verb.PUT;
    case 5:
    case "DELETE":
      return HTTPExtension_Verb.DELETE;
    case 6:
    case "CONNECT":
      return HTTPExtension_Verb.CONNECT;
    case 7:
    case "OPTIONS":
      return HTTPExtension_Verb.OPTIONS;
    case 8:
    case "TRACE":
      return HTTPExtension_Verb.TRACE;
    case 9:
    case "PATCH":
      return HTTPExtension_Verb.PATCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HTTPExtension_Verb.UNRECOGNIZED;
  }
}

export function hTTPExtension_VerbToJSON(object: HTTPExtension_Verb): string {
  switch (object) {
    case HTTPExtension_Verb.NONE:
      return "NONE";
    case HTTPExtension_Verb.GET:
      return "GET";
    case HTTPExtension_Verb.HEAD:
      return "HEAD";
    case HTTPExtension_Verb.POST:
      return "POST";
    case HTTPExtension_Verb.PUT:
      return "PUT";
    case HTTPExtension_Verb.DELETE:
      return "DELETE";
    case HTTPExtension_Verb.CONNECT:
      return "CONNECT";
    case HTTPExtension_Verb.OPTIONS:
      return "OPTIONS";
    case HTTPExtension_Verb.TRACE:
      return "TRACE";
    case HTTPExtension_Verb.PATCH:
      return "PATCH";
    case HTTPExtension_Verb.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * InvokeRequest is the message to invoke a method with the data.
 * This message is used in InvokeService of Dapr gRPC Service and OnInvoke
 * of AppCallback gRPC service.
 */
export interface InvokeRequest {
  /** Required. method is a method name which will be invoked by caller. */
  method: string;
  /**
   * Required in unary RPCs. Bytes value or Protobuf message which caller sent.
   * Dapr treats Any.value as bytes type if Any.type_url is unset.
   */
  data:
    | Any
    | undefined;
  /**
   * The type of data content.
   *
   * This field is required if data delivers http request body
   * Otherwise, this is optional.
   */
  contentType: string;
  /**
   * HTTP specific fields if request conveys http-compatible request.
   *
   * This field is required for http-compatible request. Otherwise,
   * this field is optional.
   */
  httpExtension: HTTPExtension | undefined;
}

/**
 * InvokeResponse is the response message including data and its content type
 * from app callback.
 * This message is used in InvokeService of Dapr gRPC Service and OnInvoke
 * of AppCallback gRPC service.
 */
export interface InvokeResponse {
  /** Required in unary RPCs. The content body of InvokeService response. */
  data:
    | Any
    | undefined;
  /** Required. The type of data content. */
  contentType: string;
}

/**
 * Chunk of data sent in a streaming request or response.
 * This is used in requests including InternalInvokeRequestStream.
 */
export interface StreamPayload {
  /**
   * Data sent in the chunk.
   * The amount of data included in each chunk is up to the discretion of the sender, and can be empty.
   * Additionally, the amount of data doesn't need to be fixed and subsequent messages can send more, or less, data.
   * Receivers must not make assumptions about the number of bytes they'll receive in each chunk.
   */
  data: Uint8Array;
  /** Sequence number. This is a counter that starts from 0 and increments by 1 on each chunk sent. */
  seq: number;
}

/** StateItem represents state key, value, and additional options to save state. */
export interface StateItem {
  /** Required. The state key */
  key: string;
  /** Required. The state data for key */
  value: Uint8Array;
  /**
   * The entity tag which represents the specific version of data.
   * The exact ETag format is defined by the corresponding data store.
   */
  etag:
    | Etag
    | undefined;
  /** The metadata which will be passed to state store component. */
  metadata: { [key: string]: string };
  /** Options for concurrency and consistency to save the state. */
  options: StateOptions | undefined;
}

export interface StateItem_MetadataEntry {
  key: string;
  value: string;
}

/** Etag represents a state item version */
export interface Etag {
  /** value sets the etag value */
  value: string;
}

/** StateOptions configures concurrency and consistency for state operations */
export interface StateOptions {
  concurrency: StateOptions_StateConcurrency;
  consistency: StateOptions_StateConsistency;
}

/** Enum describing the supported concurrency for state. */
export enum StateOptions_StateConcurrency {
  CONCURRENCY_UNSPECIFIED = 0,
  CONCURRENCY_FIRST_WRITE = 1,
  CONCURRENCY_LAST_WRITE = 2,
  UNRECOGNIZED = -1,
}

export function stateOptions_StateConcurrencyFromJSON(object: any): StateOptions_StateConcurrency {
  switch (object) {
    case 0:
    case "CONCURRENCY_UNSPECIFIED":
      return StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED;
    case 1:
    case "CONCURRENCY_FIRST_WRITE":
      return StateOptions_StateConcurrency.CONCURRENCY_FIRST_WRITE;
    case 2:
    case "CONCURRENCY_LAST_WRITE":
      return StateOptions_StateConcurrency.CONCURRENCY_LAST_WRITE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StateOptions_StateConcurrency.UNRECOGNIZED;
  }
}

export function stateOptions_StateConcurrencyToJSON(object: StateOptions_StateConcurrency): string {
  switch (object) {
    case StateOptions_StateConcurrency.CONCURRENCY_UNSPECIFIED:
      return "CONCURRENCY_UNSPECIFIED";
    case StateOptions_StateConcurrency.CONCURRENCY_FIRST_WRITE:
      return "CONCURRENCY_FIRST_WRITE";
    case StateOptions_StateConcurrency.CONCURRENCY_LAST_WRITE:
      return "CONCURRENCY_LAST_WRITE";
    case StateOptions_StateConcurrency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Enum describing the supported consistency for state. */
export enum StateOptions_StateConsistency {
  CONSISTENCY_UNSPECIFIED = 0,
  CONSISTENCY_EVENTUAL = 1,
  CONSISTENCY_STRONG = 2,
  UNRECOGNIZED = -1,
}

export function stateOptions_StateConsistencyFromJSON(object: any): StateOptions_StateConsistency {
  switch (object) {
    case 0:
    case "CONSISTENCY_UNSPECIFIED":
      return StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED;
    case 1:
    case "CONSISTENCY_EVENTUAL":
      return StateOptions_StateConsistency.CONSISTENCY_EVENTUAL;
    case 2:
    case "CONSISTENCY_STRONG":
      return StateOptions_StateConsistency.CONSISTENCY_STRONG;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StateOptions_StateConsistency.UNRECOGNIZED;
  }
}

export function stateOptions_StateConsistencyToJSON(object: StateOptions_StateConsistency): string {
  switch (object) {
    case StateOptions_StateConsistency.CONSISTENCY_UNSPECIFIED:
      return "CONSISTENCY_UNSPECIFIED";
    case StateOptions_StateConsistency.CONSISTENCY_EVENTUAL:
      return "CONSISTENCY_EVENTUAL";
    case StateOptions_StateConsistency.CONSISTENCY_STRONG:
      return "CONSISTENCY_STRONG";
    case StateOptions_StateConsistency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ConfigurationItem represents all the configuration with its name(key). */
export interface ConfigurationItem {
  /** Required. The value of configuration item. */
  value: string;
  /** Version is response only and cannot be fetched. Store is not expected to keep all versions available */
  version: string;
  /** the metadata which will be passed to/from configuration store component. */
  metadata: { [key: string]: string };
}

export interface ConfigurationItem_MetadataEntry {
  key: string;
  value: string;
}

function createBaseHTTPExtension(): HTTPExtension {
  return { verb: 0, querystring: "" };
}

export const HTTPExtension = {
  encode(message: HTTPExtension, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.verb !== 0) {
      writer.uint32(8).int32(message.verb);
    }
    if (message.querystring !== "") {
      writer.uint32(18).string(message.querystring);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HTTPExtension {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHTTPExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.verb = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.querystring = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HTTPExtension {
    return {
      verb: isSet(object.verb) ? hTTPExtension_VerbFromJSON(object.verb) : 0,
      querystring: isSet(object.querystring) ? globalThis.String(object.querystring) : "",
    };
  },

  toJSON(message: HTTPExtension): unknown {
    const obj: any = {};
    if (message.verb !== 0) {
      obj.verb = hTTPExtension_VerbToJSON(message.verb);
    }
    if (message.querystring !== "") {
      obj.querystring = message.querystring;
    }
    return obj;
  },

  create(base?: DeepPartial<HTTPExtension>): HTTPExtension {
    return HTTPExtension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HTTPExtension>): HTTPExtension {
    const message = createBaseHTTPExtension();
    message.verb = object.verb ?? 0;
    message.querystring = object.querystring ?? "";
    return message;
  },
};

function createBaseInvokeRequest(): InvokeRequest {
  return { method: "", data: undefined, contentType: "", httpExtension: undefined };
}

export const InvokeRequest = {
  encode(message: InvokeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.method !== "") {
      writer.uint32(10).string(message.method);
    }
    if (message.data !== undefined) {
      Any.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    if (message.contentType !== "") {
      writer.uint32(26).string(message.contentType);
    }
    if (message.httpExtension !== undefined) {
      HTTPExtension.encode(message.httpExtension, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.method = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = Any.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.httpExtension = HTTPExtension.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeRequest {
    return {
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      data: isSet(object.data) ? Any.fromJSON(object.data) : undefined,
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      httpExtension: isSet(object.httpExtension) ? HTTPExtension.fromJSON(object.httpExtension) : undefined,
    };
  },

  toJSON(message: InvokeRequest): unknown {
    const obj: any = {};
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.data !== undefined) {
      obj.data = Any.toJSON(message.data);
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.httpExtension !== undefined) {
      obj.httpExtension = HTTPExtension.toJSON(message.httpExtension);
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeRequest>): InvokeRequest {
    return InvokeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeRequest>): InvokeRequest {
    const message = createBaseInvokeRequest();
    message.method = object.method ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? Any.fromPartial(object.data) : undefined;
    message.contentType = object.contentType ?? "";
    message.httpExtension = (object.httpExtension !== undefined && object.httpExtension !== null)
      ? HTTPExtension.fromPartial(object.httpExtension)
      : undefined;
    return message;
  },
};

function createBaseInvokeResponse(): InvokeResponse {
  return { data: undefined, contentType: "" };
}

export const InvokeResponse = {
  encode(message: InvokeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data !== undefined) {
      Any.encode(message.data, writer.uint32(10).fork()).ldelim();
    }
    if (message.contentType !== "") {
      writer.uint32(18).string(message.contentType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = Any.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contentType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeResponse {
    return {
      data: isSet(object.data) ? Any.fromJSON(object.data) : undefined,
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
    };
  },

  toJSON(message: InvokeResponse): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = Any.toJSON(message.data);
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeResponse>): InvokeResponse {
    return InvokeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeResponse>): InvokeResponse {
    const message = createBaseInvokeResponse();
    message.data = (object.data !== undefined && object.data !== null) ? Any.fromPartial(object.data) : undefined;
    message.contentType = object.contentType ?? "";
    return message;
  },
};

function createBaseStreamPayload(): StreamPayload {
  return { data: new Uint8Array(0), seq: 0 };
}

export const StreamPayload = {
  encode(message: StreamPayload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.seq !== 0) {
      writer.uint32(16).uint64(message.seq);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StreamPayload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.seq = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamPayload {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      seq: isSet(object.seq) ? globalThis.Number(object.seq) : 0,
    };
  },

  toJSON(message: StreamPayload): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.seq !== 0) {
      obj.seq = Math.round(message.seq);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamPayload>): StreamPayload {
    return StreamPayload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamPayload>): StreamPayload {
    const message = createBaseStreamPayload();
    message.data = object.data ?? new Uint8Array(0);
    message.seq = object.seq ?? 0;
    return message;
  },
};

function createBaseStateItem(): StateItem {
  return { key: "", value: new Uint8Array(0), etag: undefined, metadata: {}, options: undefined };
}

export const StateItem = {
  encode(message: StateItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    if (message.etag !== undefined) {
      Etag.encode(message.etag, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      StateItem_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    if (message.options !== undefined) {
      StateOptions.encode(message.options, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StateItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.etag = Etag.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = StateItem_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.options = StateOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StateItem {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
      etag: isSet(object.etag) ? Etag.fromJSON(object.etag) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      options: isSet(object.options) ? StateOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: StateItem): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.etag !== undefined) {
      obj.etag = Etag.toJSON(message.etag);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.options !== undefined) {
      obj.options = StateOptions.toJSON(message.options);
    }
    return obj;
  },

  create(base?: DeepPartial<StateItem>): StateItem {
    return StateItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StateItem>): StateItem {
    const message = createBaseStateItem();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    message.etag = (object.etag !== undefined && object.etag !== null) ? Etag.fromPartial(object.etag) : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.options = (object.options !== undefined && object.options !== null)
      ? StateOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseStateItem_MetadataEntry(): StateItem_MetadataEntry {
  return { key: "", value: "" };
}

export const StateItem_MetadataEntry = {
  encode(message: StateItem_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StateItem_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateItem_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StateItem_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: StateItem_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<StateItem_MetadataEntry>): StateItem_MetadataEntry {
    return StateItem_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StateItem_MetadataEntry>): StateItem_MetadataEntry {
    const message = createBaseStateItem_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEtag(): Etag {
  return { value: "" };
}

export const Etag = {
  encode(message: Etag, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Etag {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEtag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Etag {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: Etag): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Etag>): Etag {
    return Etag.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Etag>): Etag {
    const message = createBaseEtag();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStateOptions(): StateOptions {
  return { concurrency: 0, consistency: 0 };
}

export const StateOptions = {
  encode(message: StateOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.concurrency !== 0) {
      writer.uint32(8).int32(message.concurrency);
    }
    if (message.consistency !== 0) {
      writer.uint32(16).int32(message.consistency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StateOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStateOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.concurrency = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.consistency = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StateOptions {
    return {
      concurrency: isSet(object.concurrency) ? stateOptions_StateConcurrencyFromJSON(object.concurrency) : 0,
      consistency: isSet(object.consistency) ? stateOptions_StateConsistencyFromJSON(object.consistency) : 0,
    };
  },

  toJSON(message: StateOptions): unknown {
    const obj: any = {};
    if (message.concurrency !== 0) {
      obj.concurrency = stateOptions_StateConcurrencyToJSON(message.concurrency);
    }
    if (message.consistency !== 0) {
      obj.consistency = stateOptions_StateConsistencyToJSON(message.consistency);
    }
    return obj;
  },

  create(base?: DeepPartial<StateOptions>): StateOptions {
    return StateOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StateOptions>): StateOptions {
    const message = createBaseStateOptions();
    message.concurrency = object.concurrency ?? 0;
    message.consistency = object.consistency ?? 0;
    return message;
  },
};

function createBaseConfigurationItem(): ConfigurationItem {
  return { value: "", version: "", metadata: {} };
}

export const ConfigurationItem = {
  encode(message: ConfigurationItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ConfigurationItem_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfigurationItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigurationItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = ConfigurationItem_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigurationItem {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ConfigurationItem): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ConfigurationItem>): ConfigurationItem {
    return ConfigurationItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfigurationItem>): ConfigurationItem {
    const message = createBaseConfigurationItem();
    message.value = object.value ?? "";
    message.version = object.version ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseConfigurationItem_MetadataEntry(): ConfigurationItem_MetadataEntry {
  return { key: "", value: "" };
}

export const ConfigurationItem_MetadataEntry = {
  encode(message: ConfigurationItem_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConfigurationItem_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigurationItem_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigurationItem_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ConfigurationItem_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ConfigurationItem_MetadataEntry>): ConfigurationItem_MetadataEntry {
    return ConfigurationItem_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfigurationItem_MetadataEntry>): ConfigurationItem_MetadataEntry {
    const message = createBaseConfigurationItem_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
