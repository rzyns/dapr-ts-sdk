// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.180.0
//   protoc               v3.19.1
// source: dapr/proto/runtime/v1/dapr.proto

/* eslint-disable */
import { type CallContext, type CallOptions } from "nice-grpc-common";
import _m0 from "protobufjs/minimal.js";
import { Any } from "../../../../google/protobuf/any.js";
import { Empty } from "../../../../google/protobuf/empty.js";
import { Timestamp } from "../../../../google/protobuf/timestamp.js";
import {
  ConfigurationItem,
  Etag,
  InvokeRequest,
  InvokeResponse,
  StateItem,
  StateOptions,
  StateOptions_StateConsistency,
  stateOptions_StateConsistencyFromJSON,
  stateOptions_StateConsistencyToJSON,
  StreamPayload,
} from "../../common/v1/common.js";
import { TopicEventRequest, TopicEventResponse } from "./appcallback.js";

export const protobufPackage = "dapr.proto.runtime.v1";

/** InvokeServiceRequest represents the request message for Service invocation. */
export interface InvokeServiceRequest {
  /** Required. Callee's app id. */
  id: string;
  /** Required. message which will be delivered to callee. */
  message: InvokeRequest | undefined;
}

/** GetStateRequest is the message to get key-value states from specific state store. */
export interface GetStateRequest {
  /** The name of state store. */
  storeName: string;
  /** The key of the desired state */
  key: string;
  /** The read consistency of the state store. */
  consistency: StateOptions_StateConsistency;
  /** The metadata which will be sent to state store components. */
  metadata: { [key: string]: string };
}

export interface GetStateRequest_MetadataEntry {
  key: string;
  value: string;
}

/** GetBulkStateRequest is the message to get a list of key-value states from specific state store. */
export interface GetBulkStateRequest {
  /** The name of state store. */
  storeName: string;
  /** The keys to get. */
  keys: string[];
  /** The number of parallel operations executed on the state store for a get operation. */
  parallelism: number;
  /** The metadata which will be sent to state store components. */
  metadata: { [key: string]: string };
}

export interface GetBulkStateRequest_MetadataEntry {
  key: string;
  value: string;
}

/** GetBulkStateResponse is the response conveying the list of state values. */
export interface GetBulkStateResponse {
  /** The list of items containing the keys to get values for. */
  items: BulkStateItem[];
}

/**
 * BulkStateItem is the response item for a bulk get operation.
 * Return values include the item key, data and etag.
 */
export interface BulkStateItem {
  /** state item key */
  key: string;
  /** The byte array data */
  data: Uint8Array;
  /**
   * The entity tag which represents the specific version of data.
   * ETag format is defined by the corresponding data store.
   */
  etag: string;
  /** The error that was returned from the state store in case of a failed get operation. */
  error: string;
  /** The metadata which will be sent to app. */
  metadata: { [key: string]: string };
}

export interface BulkStateItem_MetadataEntry {
  key: string;
  value: string;
}

/** GetStateResponse is the response conveying the state value and etag. */
export interface GetStateResponse {
  /** The byte array data */
  data: Uint8Array;
  /**
   * The entity tag which represents the specific version of data.
   * ETag format is defined by the corresponding data store.
   */
  etag: string;
  /** The metadata which will be sent to app. */
  metadata: { [key: string]: string };
}

export interface GetStateResponse_MetadataEntry {
  key: string;
  value: string;
}

/** DeleteStateRequest is the message to delete key-value states in the specific state store. */
export interface DeleteStateRequest {
  /** The name of state store. */
  storeName: string;
  /** The key of the desired state */
  key: string;
  /**
   * The entity tag which represents the specific version of data.
   * The exact ETag format is defined by the corresponding data store.
   */
  etag:
    | Etag
    | undefined;
  /**
   * State operation options which includes concurrency/
   * consistency/retry_policy.
   */
  options:
    | StateOptions
    | undefined;
  /** The metadata which will be sent to state store components. */
  metadata: { [key: string]: string };
}

export interface DeleteStateRequest_MetadataEntry {
  key: string;
  value: string;
}

/** DeleteBulkStateRequest is the message to delete a list of key-value states from specific state store. */
export interface DeleteBulkStateRequest {
  /** The name of state store. */
  storeName: string;
  /** The array of the state key values. */
  states: StateItem[];
}

/** SaveStateRequest is the message to save multiple states into state store. */
export interface SaveStateRequest {
  /** The name of state store. */
  storeName: string;
  /** The array of the state key values. */
  states: StateItem[];
}

/** QueryStateRequest is the message to query state store. */
export interface QueryStateRequest {
  /** The name of state store. */
  storeName: string;
  /** The query in JSON format. */
  query: string;
  /** The metadata which will be sent to state store components. */
  metadata: { [key: string]: string };
}

export interface QueryStateRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface QueryStateItem {
  /** The object key. */
  key: string;
  /** The object value. */
  data: Uint8Array;
  /**
   * The entity tag which represents the specific version of data.
   * ETag format is defined by the corresponding data store.
   */
  etag: string;
  /** The error message indicating an error in processing of the query result. */
  error: string;
}

/** QueryStateResponse is the response conveying the query results. */
export interface QueryStateResponse {
  /** An array of query results. */
  results: QueryStateItem[];
  /** Pagination token. */
  token: string;
  /** The metadata which will be sent to app. */
  metadata: { [key: string]: string };
}

export interface QueryStateResponse_MetadataEntry {
  key: string;
  value: string;
}

/** PublishEventRequest is the message to publish event data to pubsub topic */
export interface PublishEventRequest {
  /** The name of the pubsub component */
  pubsubName: string;
  /** The pubsub topic */
  topic: string;
  /** The data which will be published to topic. */
  data: Uint8Array;
  /** The content type for the data (optional). */
  dataContentType: string;
  /**
   * The metadata passing to pub components
   *
   * metadata property:
   * - key : the key of the message.
   */
  metadata: { [key: string]: string };
}

export interface PublishEventRequest_MetadataEntry {
  key: string;
  value: string;
}

/** BulkPublishRequest is the message to bulk publish events to pubsub topic */
export interface BulkPublishRequest {
  /** The name of the pubsub component */
  pubsubName: string;
  /** The pubsub topic */
  topic: string;
  /** The entries which contain the individual events and associated details to be published */
  entries: BulkPublishRequestEntry[];
  /** The request level metadata passing to to the pubsub components */
  metadata: { [key: string]: string };
}

export interface BulkPublishRequest_MetadataEntry {
  key: string;
  value: string;
}

/** BulkPublishRequestEntry is the message containing the event to be bulk published */
export interface BulkPublishRequestEntry {
  /** The request scoped unique ID referring to this message. Used to map status in response */
  entryId: string;
  /** The event which will be pulished to the topic */
  event: Uint8Array;
  /** The content type for the event */
  contentType: string;
  /** The event level metadata passing to the pubsub component */
  metadata: { [key: string]: string };
}

export interface BulkPublishRequestEntry_MetadataEntry {
  key: string;
  value: string;
}

/** BulkPublishResponse is the message returned from a BulkPublishEvent call */
export interface BulkPublishResponse {
  /** The entries for different events that failed publish in the BulkPublishEvent call */
  failedEntries: BulkPublishResponseFailedEntry[];
}

/** BulkPublishResponseFailedEntry is the message containing the entryID and error of a failed event in BulkPublishEvent call */
export interface BulkPublishResponseFailedEntry {
  /** The response scoped unique ID referring to this message */
  entryId: string;
  /** The error message if any on failure */
  error: string;
}

/**
 * SubscribeTopicEventsRequestAlpha1 is a message containing the details for
 * subscribing to a topic via streaming.
 * The first message must always be the initial request. All subsequent
 * messages must be event responses.
 */
export interface SubscribeTopicEventsRequestAlpha1 {
  initialRequest?: SubscribeTopicEventsInitialRequestAlpha1 | undefined;
  eventResponse?: SubscribeTopicEventsResponseAlpha1 | undefined;
}

/**
 * SubscribeTopicEventsInitialRequestAlpha1 is the initial message containing the
 * details for subscribing to a topic via streaming.
 */
export interface SubscribeTopicEventsInitialRequestAlpha1 {
  /** The name of the pubsub component */
  pubsubName: string;
  /** The pubsub topic */
  topic: string;
  /**
   * The metadata passing to pub components
   *
   * metadata property:
   * - key : the key of the message.
   */
  metadata: { [key: string]: string };
  /**
   * dead_letter_topic is the topic to which messages that fail to be processed
   * are sent.
   */
  deadLetterTopic?: string | undefined;
}

export interface SubscribeTopicEventsInitialRequestAlpha1_MetadataEntry {
  key: string;
  value: string;
}

/**
 * SubscribeTopicEventsResponseAlpha1 is a message containing the result of a
 * subscription to a topic.
 */
export interface SubscribeTopicEventsResponseAlpha1 {
  /** id is the unique identifier for the subscription request. */
  id: string;
  /** status is the result of the subscription request. */
  status: TopicEventResponse | undefined;
}

/** InvokeBindingRequest is the message to send data to output bindings */
export interface InvokeBindingRequest {
  /** The name of the output binding to invoke. */
  name: string;
  /** The data which will be sent to output binding. */
  data: Uint8Array;
  /**
   * The metadata passing to output binding components
   *
   * Common metadata property:
   * - ttlInSeconds : the time to live in seconds for the message.
   * If set in the binding definition will cause all messages to
   * have a default time to live. The message ttl overrides any value
   * in the binding definition.
   */
  metadata: { [key: string]: string };
  /** The name of the operation type for the binding to invoke */
  operation: string;
}

export interface InvokeBindingRequest_MetadataEntry {
  key: string;
  value: string;
}

/** InvokeBindingResponse is the message returned from an output binding invocation */
export interface InvokeBindingResponse {
  /** The data which will be sent to output binding. */
  data: Uint8Array;
  /** The metadata returned from an external system */
  metadata: { [key: string]: string };
}

export interface InvokeBindingResponse_MetadataEntry {
  key: string;
  value: string;
}

/** GetSecretRequest is the message to get secret from secret store. */
export interface GetSecretRequest {
  /** The name of secret store. */
  storeName: string;
  /** The name of secret key. */
  key: string;
  /** The metadata which will be sent to secret store components. */
  metadata: { [key: string]: string };
}

export interface GetSecretRequest_MetadataEntry {
  key: string;
  value: string;
}

/** GetSecretResponse is the response message to convey the requested secret. */
export interface GetSecretResponse {
  /**
   * data is the secret value. Some secret store, such as kubernetes secret
   * store, can save multiple secrets for single secret key.
   */
  data: { [key: string]: string };
}

export interface GetSecretResponse_DataEntry {
  key: string;
  value: string;
}

/** GetBulkSecretRequest is the message to get the secrets from secret store. */
export interface GetBulkSecretRequest {
  /** The name of secret store. */
  storeName: string;
  /** The metadata which will be sent to secret store components. */
  metadata: { [key: string]: string };
}

export interface GetBulkSecretRequest_MetadataEntry {
  key: string;
  value: string;
}

/** SecretResponse is a map of decrypted string/string values */
export interface SecretResponse {
  secrets: { [key: string]: string };
}

export interface SecretResponse_SecretsEntry {
  key: string;
  value: string;
}

/** GetBulkSecretResponse is the response message to convey the requested secrets. */
export interface GetBulkSecretResponse {
  /**
   * data hold the secret values. Some secret store, such as kubernetes secret
   * store, can save multiple secrets for single secret key.
   */
  data: { [key: string]: SecretResponse };
}

export interface GetBulkSecretResponse_DataEntry {
  key: string;
  value: SecretResponse | undefined;
}

/** TransactionalStateOperation is the message to execute a specified operation with a key-value pair. */
export interface TransactionalStateOperation {
  /** The type of operation to be executed */
  operationType: string;
  /** State values to be operated on */
  request: StateItem | undefined;
}

/** ExecuteStateTransactionRequest is the message to execute multiple operations on a specified store. */
export interface ExecuteStateTransactionRequest {
  /** Required. name of state store. */
  storeName: string;
  /** Required. transactional operation list. */
  operations: TransactionalStateOperation[];
  /** The metadata used for transactional operations. */
  metadata: { [key: string]: string };
}

export interface ExecuteStateTransactionRequest_MetadataEntry {
  key: string;
  value: string;
}

/** RegisterActorTimerRequest is the message to register a timer for an actor of a given type and id. */
export interface RegisterActorTimerRequest {
  actorType: string;
  actorId: string;
  name: string;
  dueTime: string;
  period: string;
  callback: string;
  data: Uint8Array;
  ttl: string;
}

/** UnregisterActorTimerRequest is the message to unregister an actor timer */
export interface UnregisterActorTimerRequest {
  actorType: string;
  actorId: string;
  name: string;
}

/** RegisterActorReminderRequest is the message to register a reminder for an actor of a given type and id. */
export interface RegisterActorReminderRequest {
  actorType: string;
  actorId: string;
  name: string;
  dueTime: string;
  period: string;
  data: Uint8Array;
  ttl: string;
}

/** UnregisterActorReminderRequest is the message to unregister an actor reminder. */
export interface UnregisterActorReminderRequest {
  actorType: string;
  actorId: string;
  name: string;
}

/** GetActorStateRequest is the message to get key-value states from specific actor. */
export interface GetActorStateRequest {
  actorType: string;
  actorId: string;
  key: string;
}

/** GetActorStateResponse is the response conveying the actor's state value. */
export interface GetActorStateResponse {
  data: Uint8Array;
  /** The metadata which will be sent to app. */
  metadata: { [key: string]: string };
}

export interface GetActorStateResponse_MetadataEntry {
  key: string;
  value: string;
}

/** ExecuteActorStateTransactionRequest is the message to execute multiple operations on a specified actor. */
export interface ExecuteActorStateTransactionRequest {
  actorType: string;
  actorId: string;
  operations: TransactionalActorStateOperation[];
}

/** TransactionalActorStateOperation is the message to execute a specified operation with a key-value pair. */
export interface TransactionalActorStateOperation {
  operationType: string;
  key: string;
  value:
    | Any
    | undefined;
  /**
   * The metadata used for transactional operations.
   *
   * Common metadata property:
   * - ttlInSeconds : the time to live in seconds for the stored value.
   */
  metadata: { [key: string]: string };
}

export interface TransactionalActorStateOperation_MetadataEntry {
  key: string;
  value: string;
}

/** InvokeActorRequest is the message to call an actor. */
export interface InvokeActorRequest {
  actorType: string;
  actorId: string;
  method: string;
  data: Uint8Array;
  metadata: { [key: string]: string };
}

export interface InvokeActorRequest_MetadataEntry {
  key: string;
  value: string;
}

/** InvokeActorResponse is the method that returns an actor invocation response. */
export interface InvokeActorResponse {
  data: Uint8Array;
}

/** GetMetadataRequest is the message for the GetMetadata request. */
export interface GetMetadataRequest {
}

/** GetMetadataResponse is a message that is returned on GetMetadata rpc call. */
export interface GetMetadataResponse {
  id: string;
  /**
   * Deprecated alias for actor_runtime.active_actors.
   *
   * @deprecated
   */
  activeActorsCount: ActiveActorsCount[];
  registeredComponents: RegisteredComponents[];
  extendedMetadata: { [key: string]: string };
  subscriptions: PubsubSubscription[];
  httpEndpoints: MetadataHTTPEndpoint[];
  appConnectionProperties: AppConnectionProperties | undefined;
  runtimeVersion: string;
  enabledFeatures: string[];
  actorRuntime: ActorRuntime | undefined;
}

export interface GetMetadataResponse_ExtendedMetadataEntry {
  key: string;
  value: string;
}

export interface ActorRuntime {
  /** Contains an enum indicating whether the actor runtime has been initialized. */
  runtimeStatus: ActorRuntime_ActorRuntimeStatus;
  /** Count of active actors per type. */
  activeActors: ActiveActorsCount[];
  /** Indicates whether the actor runtime is ready to host actors. */
  hostReady: boolean;
  /** Custom message from the placement provider. */
  placement: string;
}

export enum ActorRuntime_ActorRuntimeStatus {
  /** INITIALIZING - Indicates that the actor runtime is still being initialized. */
  INITIALIZING = 0,
  /**
   * DISABLED - Indicates that the actor runtime is disabled.
   * This normally happens when Dapr is started without "placement-host-address"
   */
  DISABLED = 1,
  /** RUNNING - Indicates the actor runtime is running, either as an actor host or client. */
  RUNNING = 2,
  UNRECOGNIZED = -1,
}

export function actorRuntime_ActorRuntimeStatusFromJSON(object: any): ActorRuntime_ActorRuntimeStatus {
  switch (object) {
    case 0:
    case "INITIALIZING":
      return ActorRuntime_ActorRuntimeStatus.INITIALIZING;
    case 1:
    case "DISABLED":
      return ActorRuntime_ActorRuntimeStatus.DISABLED;
    case 2:
    case "RUNNING":
      return ActorRuntime_ActorRuntimeStatus.RUNNING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ActorRuntime_ActorRuntimeStatus.UNRECOGNIZED;
  }
}

export function actorRuntime_ActorRuntimeStatusToJSON(object: ActorRuntime_ActorRuntimeStatus): string {
  switch (object) {
    case ActorRuntime_ActorRuntimeStatus.INITIALIZING:
      return "INITIALIZING";
    case ActorRuntime_ActorRuntimeStatus.DISABLED:
      return "DISABLED";
    case ActorRuntime_ActorRuntimeStatus.RUNNING:
      return "RUNNING";
    case ActorRuntime_ActorRuntimeStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ActiveActorsCount {
  type: string;
  count: number;
}

export interface RegisteredComponents {
  name: string;
  type: string;
  version: string;
  capabilities: string[];
}

export interface MetadataHTTPEndpoint {
  name: string;
}

export interface AppConnectionProperties {
  port: number;
  protocol: string;
  channelAddress: string;
  maxConcurrency: number;
  health: AppConnectionHealthProperties | undefined;
}

export interface AppConnectionHealthProperties {
  healthCheckPath: string;
  healthProbeInterval: string;
  healthProbeTimeout: string;
  healthThreshold: number;
}

export interface PubsubSubscription {
  pubsubName: string;
  topic: string;
  metadata: { [key: string]: string };
  rules: PubsubSubscriptionRules | undefined;
  deadLetterTopic: string;
}

export interface PubsubSubscription_MetadataEntry {
  key: string;
  value: string;
}

export interface PubsubSubscriptionRules {
  rules: PubsubSubscriptionRule[];
}

export interface PubsubSubscriptionRule {
  match: string;
  path: string;
}

export interface SetMetadataRequest {
  key: string;
  value: string;
}

/** GetConfigurationRequest is the message to get a list of key-value configuration from specified configuration store. */
export interface GetConfigurationRequest {
  /** Required. The name of configuration store. */
  storeName: string;
  /**
   * Optional. The key of the configuration item to fetch.
   * If set, only query for the specified configuration items.
   * Empty list means fetch all.
   */
  keys: string[];
  /** Optional. The metadata which will be sent to configuration store components. */
  metadata: { [key: string]: string };
}

export interface GetConfigurationRequest_MetadataEntry {
  key: string;
  value: string;
}

/**
 * GetConfigurationResponse is the response conveying the list of configuration values.
 * It should be the FULL configuration of specified application which contains all of its configuration items.
 */
export interface GetConfigurationResponse {
  items: { [key: string]: ConfigurationItem };
}

export interface GetConfigurationResponse_ItemsEntry {
  key: string;
  value: ConfigurationItem | undefined;
}

/** SubscribeConfigurationRequest is the message to get a list of key-value configuration from specified configuration store. */
export interface SubscribeConfigurationRequest {
  /** The name of configuration store. */
  storeName: string;
  /**
   * Optional. The key of the configuration item to fetch.
   * If set, only query for the specified configuration items.
   * Empty list means fetch all.
   */
  keys: string[];
  /** The metadata which will be sent to configuration store components. */
  metadata: { [key: string]: string };
}

export interface SubscribeConfigurationRequest_MetadataEntry {
  key: string;
  value: string;
}

/** UnSubscribeConfigurationRequest is the message to stop watching the key-value configuration. */
export interface UnsubscribeConfigurationRequest {
  /** The name of configuration store. */
  storeName: string;
  /** The id to unsubscribe. */
  id: string;
}

export interface SubscribeConfigurationResponse {
  /** Subscribe id, used to stop subscription. */
  id: string;
  /** The list of items containing configuration values */
  items: { [key: string]: ConfigurationItem };
}

export interface SubscribeConfigurationResponse_ItemsEntry {
  key: string;
  value: ConfigurationItem | undefined;
}

export interface UnsubscribeConfigurationResponse {
  ok: boolean;
  message: string;
}

export interface TryLockRequest {
  /** Required. The lock store name,e.g. `redis`. */
  storeName: string;
  /**
   * Required. resource_id is the lock key. e.g. `order_id_111`
   * It stands for "which resource I want to protect"
   */
  resourceId: string;
  /**
   * Required. lock_owner indicate the identifier of lock owner.
   * You can generate a uuid as lock_owner.For example,in golang:
   *
   * req.LockOwner = uuid.New().String()
   *
   * This field is per request,not per process,so it is different for each request,
   * which aims to prevent multi-thread in the same process trying the same lock concurrently.
   *
   * The reason why we don't make it automatically generated is:
   * 1. If it is automatically generated,there must be a 'my_lock_owner_id' field in the response.
   * This name is so weird that we think it is inappropriate to put it into the api spec
   * 2. If we change the field 'my_lock_owner_id' in the response to 'lock_owner',which means the current lock owner of this lock,
   * we find that in some lock services users can't get the current lock owner.Actually users don't need it at all.
   * 3. When reentrant lock is needed,the existing lock_owner is required to identify client and check "whether this client can reenter this lock".
   * So this field in the request shouldn't be removed.
   */
  lockOwner: string;
  /** Required. The time before expiry.The time unit is second. */
  expiryInSeconds: number;
}

export interface TryLockResponse {
  success: boolean;
}

export interface UnlockRequest {
  storeName: string;
  /** resource_id is the lock key. */
  resourceId: string;
  lockOwner: string;
}

export interface UnlockResponse {
  status: UnlockResponse_Status;
}

export enum UnlockResponse_Status {
  SUCCESS = 0,
  LOCK_DOES_NOT_EXIST = 1,
  LOCK_BELONGS_TO_OTHERS = 2,
  INTERNAL_ERROR = 3,
  UNRECOGNIZED = -1,
}

export function unlockResponse_StatusFromJSON(object: any): UnlockResponse_Status {
  switch (object) {
    case 0:
    case "SUCCESS":
      return UnlockResponse_Status.SUCCESS;
    case 1:
    case "LOCK_DOES_NOT_EXIST":
      return UnlockResponse_Status.LOCK_DOES_NOT_EXIST;
    case 2:
    case "LOCK_BELONGS_TO_OTHERS":
      return UnlockResponse_Status.LOCK_BELONGS_TO_OTHERS;
    case 3:
    case "INTERNAL_ERROR":
      return UnlockResponse_Status.INTERNAL_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UnlockResponse_Status.UNRECOGNIZED;
  }
}

export function unlockResponse_StatusToJSON(object: UnlockResponse_Status): string {
  switch (object) {
    case UnlockResponse_Status.SUCCESS:
      return "SUCCESS";
    case UnlockResponse_Status.LOCK_DOES_NOT_EXIST:
      return "LOCK_DOES_NOT_EXIST";
    case UnlockResponse_Status.LOCK_BELONGS_TO_OTHERS:
      return "LOCK_BELONGS_TO_OTHERS";
    case UnlockResponse_Status.INTERNAL_ERROR:
      return "INTERNAL_ERROR";
    case UnlockResponse_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** SubtleGetKeyRequest is the request object for SubtleGetKeyAlpha1. */
export interface SubtleGetKeyRequest {
  /** Name of the component */
  componentName: string;
  /** Name (or name/version) of the key to use in the key vault */
  name: string;
  /** Response format */
  format: SubtleGetKeyRequest_KeyFormat;
}

export enum SubtleGetKeyRequest_KeyFormat {
  /** PEM - PEM (PKIX) (default) */
  PEM = 0,
  /** JSON - JSON (JSON Web Key) as string */
  JSON = 1,
  UNRECOGNIZED = -1,
}

export function subtleGetKeyRequest_KeyFormatFromJSON(object: any): SubtleGetKeyRequest_KeyFormat {
  switch (object) {
    case 0:
    case "PEM":
      return SubtleGetKeyRequest_KeyFormat.PEM;
    case 1:
    case "JSON":
      return SubtleGetKeyRequest_KeyFormat.JSON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SubtleGetKeyRequest_KeyFormat.UNRECOGNIZED;
  }
}

export function subtleGetKeyRequest_KeyFormatToJSON(object: SubtleGetKeyRequest_KeyFormat): string {
  switch (object) {
    case SubtleGetKeyRequest_KeyFormat.PEM:
      return "PEM";
    case SubtleGetKeyRequest_KeyFormat.JSON:
      return "JSON";
    case SubtleGetKeyRequest_KeyFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** SubtleGetKeyResponse is the response for SubtleGetKeyAlpha1. */
export interface SubtleGetKeyResponse {
  /**
   * Name (or name/version) of the key.
   * This is returned as response too in case there is a version.
   */
  name: string;
  /** Public key, encoded in the requested format */
  publicKey: string;
}

/** SubtleEncryptRequest is the request for SubtleEncryptAlpha1. */
export interface SubtleEncryptRequest {
  /** Name of the component */
  componentName: string;
  /** Message to encrypt. */
  plaintext: Uint8Array;
  /** Algorithm to use, as in the JWA standard. */
  algorithm: string;
  /** Name (or name/version) of the key. */
  keyName: string;
  /**
   * Nonce / initialization vector.
   * Ignored with asymmetric ciphers.
   */
  nonce: Uint8Array;
  /** Associated Data when using AEAD ciphers (optional). */
  associatedData: Uint8Array;
}

/** SubtleEncryptResponse is the response for SubtleEncryptAlpha1. */
export interface SubtleEncryptResponse {
  /** Encrypted ciphertext. */
  ciphertext: Uint8Array;
  /**
   * Authentication tag.
   * This is nil when not using an authenticated cipher.
   */
  tag: Uint8Array;
}

/** SubtleDecryptRequest is the request for SubtleDecryptAlpha1. */
export interface SubtleDecryptRequest {
  /** Name of the component */
  componentName: string;
  /** Message to decrypt. */
  ciphertext: Uint8Array;
  /** Algorithm to use, as in the JWA standard. */
  algorithm: string;
  /** Name (or name/version) of the key. */
  keyName: string;
  /**
   * Nonce / initialization vector.
   * Ignored with asymmetric ciphers.
   */
  nonce: Uint8Array;
  /**
   * Authentication tag.
   * This is nil when not using an authenticated cipher.
   */
  tag: Uint8Array;
  /** Associated Data when using AEAD ciphers (optional). */
  associatedData: Uint8Array;
}

/** SubtleDecryptResponse is the response for SubtleDecryptAlpha1. */
export interface SubtleDecryptResponse {
  /** Decrypted plaintext. */
  plaintext: Uint8Array;
}

/** SubtleWrapKeyRequest is the request for SubtleWrapKeyAlpha1. */
export interface SubtleWrapKeyRequest {
  /** Name of the component */
  componentName: string;
  /** Key to wrap */
  plaintextKey: Uint8Array;
  /** Algorithm to use, as in the JWA standard. */
  algorithm: string;
  /** Name (or name/version) of the key. */
  keyName: string;
  /**
   * Nonce / initialization vector.
   * Ignored with asymmetric ciphers.
   */
  nonce: Uint8Array;
  /** Associated Data when using AEAD ciphers (optional). */
  associatedData: Uint8Array;
}

/** SubtleWrapKeyResponse is the response for SubtleWrapKeyAlpha1. */
export interface SubtleWrapKeyResponse {
  /** Wrapped key. */
  wrappedKey: Uint8Array;
  /**
   * Authentication tag.
   * This is nil when not using an authenticated cipher.
   */
  tag: Uint8Array;
}

/** SubtleUnwrapKeyRequest is the request for SubtleUnwrapKeyAlpha1. */
export interface SubtleUnwrapKeyRequest {
  /** Name of the component */
  componentName: string;
  /** Wrapped key. */
  wrappedKey: Uint8Array;
  /** Algorithm to use, as in the JWA standard. */
  algorithm: string;
  /** Name (or name/version) of the key. */
  keyName: string;
  /**
   * Nonce / initialization vector.
   * Ignored with asymmetric ciphers.
   */
  nonce: Uint8Array;
  /**
   * Authentication tag.
   * This is nil when not using an authenticated cipher.
   */
  tag: Uint8Array;
  /** Associated Data when using AEAD ciphers (optional). */
  associatedData: Uint8Array;
}

/** SubtleUnwrapKeyResponse is the response for SubtleUnwrapKeyAlpha1. */
export interface SubtleUnwrapKeyResponse {
  /** Key in plaintext */
  plaintextKey: Uint8Array;
}

/** SubtleSignRequest is the request for SubtleSignAlpha1. */
export interface SubtleSignRequest {
  /** Name of the component */
  componentName: string;
  /** Digest to sign. */
  digest: Uint8Array;
  /** Algorithm to use, as in the JWA standard. */
  algorithm: string;
  /** Name (or name/version) of the key. */
  keyName: string;
}

/** SubtleSignResponse is the response for SubtleSignAlpha1. */
export interface SubtleSignResponse {
  /** The signature that was computed */
  signature: Uint8Array;
}

/** SubtleVerifyRequest is the request for SubtleVerifyAlpha1. */
export interface SubtleVerifyRequest {
  /** Name of the component */
  componentName: string;
  /** Digest of the message. */
  digest: Uint8Array;
  /** Algorithm to use, as in the JWA standard. */
  algorithm: string;
  /** Name (or name/version) of the key. */
  keyName: string;
  /** Signature to verify. */
  signature: Uint8Array;
}

/** SubtleVerifyResponse is the response for SubtleVerifyAlpha1. */
export interface SubtleVerifyResponse {
  /** True if the signature is valid. */
  valid: boolean;
}

/** EncryptRequest is the request for EncryptAlpha1. */
export interface EncryptRequest {
  /** Request details. Must be present in the first message only. */
  options:
    | EncryptRequestOptions
    | undefined;
  /** Chunk of data of arbitrary size. */
  payload: StreamPayload | undefined;
}

/** EncryptRequestOptions contains options for the first message in the EncryptAlpha1 request. */
export interface EncryptRequestOptions {
  /** Name of the component. Required. */
  componentName: string;
  /** Name (or name/version) of the key. Required. */
  keyName: string;
  /**
   * Key wrapping algorithm to use. Required.
   * Supported options include: A256KW (alias: AES), A128CBC, A192CBC, A256CBC, RSA-OAEP-256 (alias: RSA).
   */
  keyWrapAlgorithm: string;
  /** Cipher used to encrypt data (optional): "aes-gcm" (default) or "chacha20-poly1305" */
  dataEncryptionCipher: string;
  /**
   * If true, the encrypted document does not contain a key reference.
   * In that case, calls to the Decrypt method must provide a key reference (name or name/version).
   * Defaults to false.
   */
  omitDecryptionKeyName: boolean;
  /**
   * Key reference to embed in the encrypted document (name or name/version).
   * This is helpful if the reference of the key used to decrypt the document is different from the one used to encrypt it.
   * If unset, uses the reference of the key used to encrypt the document (this is the default behavior).
   * This option is ignored if omit_decryption_key_name is true.
   */
  decryptionKeyName: string;
}

/** EncryptResponse is the response for EncryptAlpha1. */
export interface EncryptResponse {
  /** Chunk of data. */
  payload: StreamPayload | undefined;
}

/** DecryptRequest is the request for DecryptAlpha1. */
export interface DecryptRequest {
  /** Request details. Must be present in the first message only. */
  options:
    | DecryptRequestOptions
    | undefined;
  /** Chunk of data of arbitrary size. */
  payload: StreamPayload | undefined;
}

/** DecryptRequestOptions contains options for the first message in the DecryptAlpha1 request. */
export interface DecryptRequestOptions {
  /** Name of the component */
  componentName: string;
  /**
   * Name (or name/version) of the key to decrypt the message.
   * Overrides any key reference included in the message if present.
   * This is required if the message doesn't include a key reference (i.e. was created with omit_decryption_key_name set to true).
   */
  keyName: string;
}

/** DecryptResponse is the response for DecryptAlpha1. */
export interface DecryptResponse {
  /** Chunk of data. */
  payload: StreamPayload | undefined;
}

/** GetWorkflowRequest is the request for GetWorkflowBeta1. */
export interface GetWorkflowRequest {
  /** ID of the workflow instance to query. */
  instanceId: string;
  /** Name of the workflow component. */
  workflowComponent: string;
}

/** GetWorkflowResponse is the response for GetWorkflowBeta1. */
export interface GetWorkflowResponse {
  /** ID of the workflow instance. */
  instanceId: string;
  /** Name of the workflow. */
  workflowName: string;
  /** The time at which the workflow instance was created. */
  createdAt:
    | Date
    | undefined;
  /** The last time at which the workflow instance had its state changed. */
  lastUpdatedAt:
    | Date
    | undefined;
  /** The current status of the workflow instance, for example, "PENDING", "RUNNING", "SUSPENDED", "COMPLETED", "FAILED", and "TERMINATED". */
  runtimeStatus: string;
  /** Additional component-specific properties of the workflow instance. */
  properties: { [key: string]: string };
}

export interface GetWorkflowResponse_PropertiesEntry {
  key: string;
  value: string;
}

/** StartWorkflowRequest is the request for StartWorkflowBeta1. */
export interface StartWorkflowRequest {
  /** The ID to assign to the started workflow instance. If empty, a random ID is generated. */
  instanceId: string;
  /** Name of the workflow component. */
  workflowComponent: string;
  /** Name of the workflow. */
  workflowName: string;
  /** Additional component-specific options for starting the workflow instance. */
  options: { [key: string]: string };
  /** Input data for the workflow instance. */
  input: Uint8Array;
}

export interface StartWorkflowRequest_OptionsEntry {
  key: string;
  value: string;
}

/** StartWorkflowResponse is the response for StartWorkflowBeta1. */
export interface StartWorkflowResponse {
  /** ID of the started workflow instance. */
  instanceId: string;
}

/** TerminateWorkflowRequest is the request for TerminateWorkflowBeta1. */
export interface TerminateWorkflowRequest {
  /** ID of the workflow instance to terminate. */
  instanceId: string;
  /** Name of the workflow component. */
  workflowComponent: string;
}

/** PauseWorkflowRequest is the request for PauseWorkflowBeta1. */
export interface PauseWorkflowRequest {
  /** ID of the workflow instance to pause. */
  instanceId: string;
  /** Name of the workflow component. */
  workflowComponent: string;
}

/** ResumeWorkflowRequest is the request for ResumeWorkflowBeta1. */
export interface ResumeWorkflowRequest {
  /** ID of the workflow instance to resume. */
  instanceId: string;
  /** Name of the workflow component. */
  workflowComponent: string;
}

/** RaiseEventWorkflowRequest is the request for RaiseEventWorkflowBeta1. */
export interface RaiseEventWorkflowRequest {
  /** ID of the workflow instance to raise an event for. */
  instanceId: string;
  /** Name of the workflow component. */
  workflowComponent: string;
  /** Name of the event. */
  eventName: string;
  /** Data associated with the event. */
  eventData: Uint8Array;
}

/** PurgeWorkflowRequest is the request for PurgeWorkflowBeta1. */
export interface PurgeWorkflowRequest {
  /** ID of the workflow instance to purge. */
  instanceId: string;
  /** Name of the workflow component. */
  workflowComponent: string;
}

/** ShutdownRequest is the request for Shutdown. */
export interface ShutdownRequest {
}

function createBaseInvokeServiceRequest(): InvokeServiceRequest {
  return { id: "", message: undefined };
}

export const InvokeServiceRequest = {
  encode(message: InvokeServiceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.message !== undefined) {
      InvokeRequest.encode(message.message, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeServiceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeServiceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = InvokeRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeServiceRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      message: isSet(object.message) ? InvokeRequest.fromJSON(object.message) : undefined,
    };
  },

  toJSON(message: InvokeServiceRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.message !== undefined) {
      obj.message = InvokeRequest.toJSON(message.message);
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeServiceRequest>): InvokeServiceRequest {
    return InvokeServiceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeServiceRequest>): InvokeServiceRequest {
    const message = createBaseInvokeServiceRequest();
    message.id = object.id ?? "";
    message.message = (object.message !== undefined && object.message !== null)
      ? InvokeRequest.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseGetStateRequest(): GetStateRequest {
  return { storeName: "", key: "", consistency: 0, metadata: {} };
}

export const GetStateRequest = {
  encode(message: GetStateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.storeName !== "") {
      writer.uint32(10).string(message.storeName);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.consistency !== 0) {
      writer.uint32(24).int32(message.consistency);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      GetStateRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.consistency = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = GetStateRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStateRequest {
    return {
      storeName: isSet(object.storeName) ? globalThis.String(object.storeName) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      consistency: isSet(object.consistency) ? stateOptions_StateConsistencyFromJSON(object.consistency) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetStateRequest): unknown {
    const obj: any = {};
    if (message.storeName !== "") {
      obj.storeName = message.storeName;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.consistency !== 0) {
      obj.consistency = stateOptions_StateConsistencyToJSON(message.consistency);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetStateRequest>): GetStateRequest {
    return GetStateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetStateRequest>): GetStateRequest {
    const message = createBaseGetStateRequest();
    message.storeName = object.storeName ?? "";
    message.key = object.key ?? "";
    message.consistency = object.consistency ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetStateRequest_MetadataEntry(): GetStateRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const GetStateRequest_MetadataEntry = {
  encode(message: GetStateRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStateRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStateRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStateRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetStateRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GetStateRequest_MetadataEntry>): GetStateRequest_MetadataEntry {
    return GetStateRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetStateRequest_MetadataEntry>): GetStateRequest_MetadataEntry {
    const message = createBaseGetStateRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetBulkStateRequest(): GetBulkStateRequest {
  return { storeName: "", keys: [], parallelism: 0, metadata: {} };
}

export const GetBulkStateRequest = {
  encode(message: GetBulkStateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.storeName !== "") {
      writer.uint32(10).string(message.storeName);
    }
    for (const v of message.keys) {
      writer.uint32(18).string(v!);
    }
    if (message.parallelism !== 0) {
      writer.uint32(24).int32(message.parallelism);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      GetBulkStateRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBulkStateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBulkStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keys.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.parallelism = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = GetBulkStateRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBulkStateRequest {
    return {
      storeName: isSet(object.storeName) ? globalThis.String(object.storeName) : "",
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => globalThis.String(e)) : [],
      parallelism: isSet(object.parallelism) ? globalThis.Number(object.parallelism) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetBulkStateRequest): unknown {
    const obj: any = {};
    if (message.storeName !== "") {
      obj.storeName = message.storeName;
    }
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    if (message.parallelism !== 0) {
      obj.parallelism = Math.round(message.parallelism);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetBulkStateRequest>): GetBulkStateRequest {
    return GetBulkStateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBulkStateRequest>): GetBulkStateRequest {
    const message = createBaseGetBulkStateRequest();
    message.storeName = object.storeName ?? "";
    message.keys = object.keys?.map((e) => e) || [];
    message.parallelism = object.parallelism ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetBulkStateRequest_MetadataEntry(): GetBulkStateRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const GetBulkStateRequest_MetadataEntry = {
  encode(message: GetBulkStateRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBulkStateRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBulkStateRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBulkStateRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetBulkStateRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBulkStateRequest_MetadataEntry>): GetBulkStateRequest_MetadataEntry {
    return GetBulkStateRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBulkStateRequest_MetadataEntry>): GetBulkStateRequest_MetadataEntry {
    const message = createBaseGetBulkStateRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetBulkStateResponse(): GetBulkStateResponse {
  return { items: [] };
}

export const GetBulkStateResponse = {
  encode(message: GetBulkStateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.items) {
      BulkStateItem.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBulkStateResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBulkStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(BulkStateItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBulkStateResponse {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => BulkStateItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetBulkStateResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => BulkStateItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetBulkStateResponse>): GetBulkStateResponse {
    return GetBulkStateResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBulkStateResponse>): GetBulkStateResponse {
    const message = createBaseGetBulkStateResponse();
    message.items = object.items?.map((e) => BulkStateItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBulkStateItem(): BulkStateItem {
  return { key: "", data: new Uint8Array(0), etag: "", error: "", metadata: {} };
}

export const BulkStateItem = {
  encode(message: BulkStateItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.etag !== "") {
      writer.uint32(26).string(message.etag);
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      BulkStateItem_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkStateItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkStateItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = BulkStateItem_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkStateItem {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BulkStateItem): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<BulkStateItem>): BulkStateItem {
    return BulkStateItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BulkStateItem>): BulkStateItem {
    const message = createBaseBulkStateItem();
    message.key = object.key ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.etag = object.etag ?? "";
    message.error = object.error ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBulkStateItem_MetadataEntry(): BulkStateItem_MetadataEntry {
  return { key: "", value: "" };
}

export const BulkStateItem_MetadataEntry = {
  encode(message: BulkStateItem_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkStateItem_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkStateItem_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkStateItem_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BulkStateItem_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BulkStateItem_MetadataEntry>): BulkStateItem_MetadataEntry {
    return BulkStateItem_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BulkStateItem_MetadataEntry>): BulkStateItem_MetadataEntry {
    const message = createBaseBulkStateItem_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetStateResponse(): GetStateResponse {
  return { data: new Uint8Array(0), etag: "", metadata: {} };
}

export const GetStateResponse = {
  encode(message: GetStateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    if (message.etag !== "") {
      writer.uint32(18).string(message.etag);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      GetStateResponse_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStateResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = GetStateResponse_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStateResponse {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetStateResponse): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetStateResponse>): GetStateResponse {
    return GetStateResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetStateResponse>): GetStateResponse {
    const message = createBaseGetStateResponse();
    message.data = object.data ?? new Uint8Array(0);
    message.etag = object.etag ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetStateResponse_MetadataEntry(): GetStateResponse_MetadataEntry {
  return { key: "", value: "" };
}

export const GetStateResponse_MetadataEntry = {
  encode(message: GetStateResponse_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStateResponse_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStateResponse_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStateResponse_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetStateResponse_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GetStateResponse_MetadataEntry>): GetStateResponse_MetadataEntry {
    return GetStateResponse_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetStateResponse_MetadataEntry>): GetStateResponse_MetadataEntry {
    const message = createBaseGetStateResponse_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDeleteStateRequest(): DeleteStateRequest {
  return { storeName: "", key: "", etag: undefined, options: undefined, metadata: {} };
}

export const DeleteStateRequest = {
  encode(message: DeleteStateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.storeName !== "") {
      writer.uint32(10).string(message.storeName);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.etag !== undefined) {
      Etag.encode(message.etag, writer.uint32(26).fork()).ldelim();
    }
    if (message.options !== undefined) {
      StateOptions.encode(message.options, writer.uint32(34).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      DeleteStateRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteStateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.etag = Etag.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.options = StateOptions.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = DeleteStateRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteStateRequest {
    return {
      storeName: isSet(object.storeName) ? globalThis.String(object.storeName) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      etag: isSet(object.etag) ? Etag.fromJSON(object.etag) : undefined,
      options: isSet(object.options) ? StateOptions.fromJSON(object.options) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: DeleteStateRequest): unknown {
    const obj: any = {};
    if (message.storeName !== "") {
      obj.storeName = message.storeName;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.etag !== undefined) {
      obj.etag = Etag.toJSON(message.etag);
    }
    if (message.options !== undefined) {
      obj.options = StateOptions.toJSON(message.options);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteStateRequest>): DeleteStateRequest {
    return DeleteStateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteStateRequest>): DeleteStateRequest {
    const message = createBaseDeleteStateRequest();
    message.storeName = object.storeName ?? "";
    message.key = object.key ?? "";
    message.etag = (object.etag !== undefined && object.etag !== null) ? Etag.fromPartial(object.etag) : undefined;
    message.options = (object.options !== undefined && object.options !== null)
      ? StateOptions.fromPartial(object.options)
      : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseDeleteStateRequest_MetadataEntry(): DeleteStateRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const DeleteStateRequest_MetadataEntry = {
  encode(message: DeleteStateRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteStateRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteStateRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteStateRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DeleteStateRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteStateRequest_MetadataEntry>): DeleteStateRequest_MetadataEntry {
    return DeleteStateRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteStateRequest_MetadataEntry>): DeleteStateRequest_MetadataEntry {
    const message = createBaseDeleteStateRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDeleteBulkStateRequest(): DeleteBulkStateRequest {
  return { storeName: "", states: [] };
}

export const DeleteBulkStateRequest = {
  encode(message: DeleteBulkStateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.storeName !== "") {
      writer.uint32(10).string(message.storeName);
    }
    for (const v of message.states) {
      StateItem.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteBulkStateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteBulkStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.states.push(StateItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteBulkStateRequest {
    return {
      storeName: isSet(object.storeName) ? globalThis.String(object.storeName) : "",
      states: globalThis.Array.isArray(object?.states) ? object.states.map((e: any) => StateItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: DeleteBulkStateRequest): unknown {
    const obj: any = {};
    if (message.storeName !== "") {
      obj.storeName = message.storeName;
    }
    if (message.states?.length) {
      obj.states = message.states.map((e) => StateItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteBulkStateRequest>): DeleteBulkStateRequest {
    return DeleteBulkStateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteBulkStateRequest>): DeleteBulkStateRequest {
    const message = createBaseDeleteBulkStateRequest();
    message.storeName = object.storeName ?? "";
    message.states = object.states?.map((e) => StateItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSaveStateRequest(): SaveStateRequest {
  return { storeName: "", states: [] };
}

export const SaveStateRequest = {
  encode(message: SaveStateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.storeName !== "") {
      writer.uint32(10).string(message.storeName);
    }
    for (const v of message.states) {
      StateItem.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SaveStateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.states.push(StateItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SaveStateRequest {
    return {
      storeName: isSet(object.storeName) ? globalThis.String(object.storeName) : "",
      states: globalThis.Array.isArray(object?.states) ? object.states.map((e: any) => StateItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: SaveStateRequest): unknown {
    const obj: any = {};
    if (message.storeName !== "") {
      obj.storeName = message.storeName;
    }
    if (message.states?.length) {
      obj.states = message.states.map((e) => StateItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SaveStateRequest>): SaveStateRequest {
    return SaveStateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SaveStateRequest>): SaveStateRequest {
    const message = createBaseSaveStateRequest();
    message.storeName = object.storeName ?? "";
    message.states = object.states?.map((e) => StateItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryStateRequest(): QueryStateRequest {
  return { storeName: "", query: "", metadata: {} };
}

export const QueryStateRequest = {
  encode(message: QueryStateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.storeName !== "") {
      writer.uint32(10).string(message.storeName);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      QueryStateRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryStateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = QueryStateRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStateRequest {
    return {
      storeName: isSet(object.storeName) ? globalThis.String(object.storeName) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: QueryStateRequest): unknown {
    const obj: any = {};
    if (message.storeName !== "") {
      obj.storeName = message.storeName;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<QueryStateRequest>): QueryStateRequest {
    return QueryStateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryStateRequest>): QueryStateRequest {
    const message = createBaseQueryStateRequest();
    message.storeName = object.storeName ?? "";
    message.query = object.query ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseQueryStateRequest_MetadataEntry(): QueryStateRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const QueryStateRequest_MetadataEntry = {
  encode(message: QueryStateRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryStateRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStateRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStateRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: QueryStateRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryStateRequest_MetadataEntry>): QueryStateRequest_MetadataEntry {
    return QueryStateRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryStateRequest_MetadataEntry>): QueryStateRequest_MetadataEntry {
    const message = createBaseQueryStateRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseQueryStateItem(): QueryStateItem {
  return { key: "", data: new Uint8Array(0), etag: "", error: "" };
}

export const QueryStateItem = {
  encode(message: QueryStateItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.etag !== "") {
      writer.uint32(26).string(message.etag);
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryStateItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStateItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStateItem {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: QueryStateItem): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryStateItem>): QueryStateItem {
    return QueryStateItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryStateItem>): QueryStateItem {
    const message = createBaseQueryStateItem();
    message.key = object.key ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.etag = object.etag ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseQueryStateResponse(): QueryStateResponse {
  return { results: [], token: "", metadata: {} };
}

export const QueryStateResponse = {
  encode(message: QueryStateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      QueryStateItem.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      QueryStateResponse_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryStateResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(QueryStateItem.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = QueryStateResponse_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStateResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => QueryStateItem.fromJSON(e))
        : [],
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: QueryStateResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => QueryStateItem.toJSON(e));
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<QueryStateResponse>): QueryStateResponse {
    return QueryStateResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryStateResponse>): QueryStateResponse {
    const message = createBaseQueryStateResponse();
    message.results = object.results?.map((e) => QueryStateItem.fromPartial(e)) || [];
    message.token = object.token ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseQueryStateResponse_MetadataEntry(): QueryStateResponse_MetadataEntry {
  return { key: "", value: "" };
}

export const QueryStateResponse_MetadataEntry = {
  encode(message: QueryStateResponse_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): QueryStateResponse_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStateResponse_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStateResponse_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: QueryStateResponse_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryStateResponse_MetadataEntry>): QueryStateResponse_MetadataEntry {
    return QueryStateResponse_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryStateResponse_MetadataEntry>): QueryStateResponse_MetadataEntry {
    const message = createBaseQueryStateResponse_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePublishEventRequest(): PublishEventRequest {
  return { pubsubName: "", topic: "", data: new Uint8Array(0), dataContentType: "", metadata: {} };
}

export const PublishEventRequest = {
  encode(message: PublishEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pubsubName !== "") {
      writer.uint32(10).string(message.pubsubName);
    }
    if (message.topic !== "") {
      writer.uint32(18).string(message.topic);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    if (message.dataContentType !== "") {
      writer.uint32(34).string(message.dataContentType);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      PublishEventRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublishEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pubsubName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dataContentType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = PublishEventRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishEventRequest {
    return {
      pubsubName: isSet(object.pubsubName) ? globalThis.String(object.pubsubName) : "",
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      dataContentType: isSet(object.dataContentType) ? globalThis.String(object.dataContentType) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: PublishEventRequest): unknown {
    const obj: any = {};
    if (message.pubsubName !== "") {
      obj.pubsubName = message.pubsubName;
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.dataContentType !== "") {
      obj.dataContentType = message.dataContentType;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<PublishEventRequest>): PublishEventRequest {
    return PublishEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublishEventRequest>): PublishEventRequest {
    const message = createBasePublishEventRequest();
    message.pubsubName = object.pubsubName ?? "";
    message.topic = object.topic ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.dataContentType = object.dataContentType ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBasePublishEventRequest_MetadataEntry(): PublishEventRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const PublishEventRequest_MetadataEntry = {
  encode(message: PublishEventRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PublishEventRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishEventRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishEventRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PublishEventRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<PublishEventRequest_MetadataEntry>): PublishEventRequest_MetadataEntry {
    return PublishEventRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublishEventRequest_MetadataEntry>): PublishEventRequest_MetadataEntry {
    const message = createBasePublishEventRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBulkPublishRequest(): BulkPublishRequest {
  return { pubsubName: "", topic: "", entries: [], metadata: {} };
}

export const BulkPublishRequest = {
  encode(message: BulkPublishRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pubsubName !== "") {
      writer.uint32(10).string(message.pubsubName);
    }
    if (message.topic !== "") {
      writer.uint32(18).string(message.topic);
    }
    for (const v of message.entries) {
      BulkPublishRequestEntry.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      BulkPublishRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkPublishRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkPublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pubsubName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entries.push(BulkPublishRequestEntry.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = BulkPublishRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkPublishRequest {
    return {
      pubsubName: isSet(object.pubsubName) ? globalThis.String(object.pubsubName) : "",
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => BulkPublishRequestEntry.fromJSON(e))
        : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BulkPublishRequest): unknown {
    const obj: any = {};
    if (message.pubsubName !== "") {
      obj.pubsubName = message.pubsubName;
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => BulkPublishRequestEntry.toJSON(e));
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<BulkPublishRequest>): BulkPublishRequest {
    return BulkPublishRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BulkPublishRequest>): BulkPublishRequest {
    const message = createBaseBulkPublishRequest();
    message.pubsubName = object.pubsubName ?? "";
    message.topic = object.topic ?? "";
    message.entries = object.entries?.map((e) => BulkPublishRequestEntry.fromPartial(e)) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBulkPublishRequest_MetadataEntry(): BulkPublishRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const BulkPublishRequest_MetadataEntry = {
  encode(message: BulkPublishRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkPublishRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkPublishRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkPublishRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BulkPublishRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BulkPublishRequest_MetadataEntry>): BulkPublishRequest_MetadataEntry {
    return BulkPublishRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BulkPublishRequest_MetadataEntry>): BulkPublishRequest_MetadataEntry {
    const message = createBaseBulkPublishRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBulkPublishRequestEntry(): BulkPublishRequestEntry {
  return { entryId: "", event: new Uint8Array(0), contentType: "", metadata: {} };
}

export const BulkPublishRequestEntry = {
  encode(message: BulkPublishRequestEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entryId !== "") {
      writer.uint32(10).string(message.entryId);
    }
    if (message.event.length !== 0) {
      writer.uint32(18).bytes(message.event);
    }
    if (message.contentType !== "") {
      writer.uint32(26).string(message.contentType);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      BulkPublishRequestEntry_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkPublishRequestEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkPublishRequestEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entryId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.event = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = BulkPublishRequestEntry_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkPublishRequestEntry {
    return {
      entryId: isSet(object.entryId) ? globalThis.String(object.entryId) : "",
      event: isSet(object.event) ? bytesFromBase64(object.event) : new Uint8Array(0),
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BulkPublishRequestEntry): unknown {
    const obj: any = {};
    if (message.entryId !== "") {
      obj.entryId = message.entryId;
    }
    if (message.event.length !== 0) {
      obj.event = base64FromBytes(message.event);
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<BulkPublishRequestEntry>): BulkPublishRequestEntry {
    return BulkPublishRequestEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BulkPublishRequestEntry>): BulkPublishRequestEntry {
    const message = createBaseBulkPublishRequestEntry();
    message.entryId = object.entryId ?? "";
    message.event = object.event ?? new Uint8Array(0);
    message.contentType = object.contentType ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBulkPublishRequestEntry_MetadataEntry(): BulkPublishRequestEntry_MetadataEntry {
  return { key: "", value: "" };
}

export const BulkPublishRequestEntry_MetadataEntry = {
  encode(message: BulkPublishRequestEntry_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkPublishRequestEntry_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkPublishRequestEntry_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkPublishRequestEntry_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BulkPublishRequestEntry_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BulkPublishRequestEntry_MetadataEntry>): BulkPublishRequestEntry_MetadataEntry {
    return BulkPublishRequestEntry_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BulkPublishRequestEntry_MetadataEntry>): BulkPublishRequestEntry_MetadataEntry {
    const message = createBaseBulkPublishRequestEntry_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBulkPublishResponse(): BulkPublishResponse {
  return { failedEntries: [] };
}

export const BulkPublishResponse = {
  encode(message: BulkPublishResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.failedEntries) {
      BulkPublishResponseFailedEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkPublishResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkPublishResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.failedEntries.push(BulkPublishResponseFailedEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkPublishResponse {
    return {
      failedEntries: globalThis.Array.isArray(object?.failedEntries)
        ? object.failedEntries.map((e: any) => BulkPublishResponseFailedEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BulkPublishResponse): unknown {
    const obj: any = {};
    if (message.failedEntries?.length) {
      obj.failedEntries = message.failedEntries.map((e) => BulkPublishResponseFailedEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BulkPublishResponse>): BulkPublishResponse {
    return BulkPublishResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BulkPublishResponse>): BulkPublishResponse {
    const message = createBaseBulkPublishResponse();
    message.failedEntries = object.failedEntries?.map((e) => BulkPublishResponseFailedEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBulkPublishResponseFailedEntry(): BulkPublishResponseFailedEntry {
  return { entryId: "", error: "" };
}

export const BulkPublishResponseFailedEntry = {
  encode(message: BulkPublishResponseFailedEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entryId !== "") {
      writer.uint32(10).string(message.entryId);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkPublishResponseFailedEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkPublishResponseFailedEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entryId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkPublishResponseFailedEntry {
    return {
      entryId: isSet(object.entryId) ? globalThis.String(object.entryId) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: BulkPublishResponseFailedEntry): unknown {
    const obj: any = {};
    if (message.entryId !== "") {
      obj.entryId = message.entryId;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<BulkPublishResponseFailedEntry>): BulkPublishResponseFailedEntry {
    return BulkPublishResponseFailedEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BulkPublishResponseFailedEntry>): BulkPublishResponseFailedEntry {
    const message = createBaseBulkPublishResponseFailedEntry();
    message.entryId = object.entryId ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseSubscribeTopicEventsRequestAlpha1(): SubscribeTopicEventsRequestAlpha1 {
  return { initialRequest: undefined, eventResponse: undefined };
}

export const SubscribeTopicEventsRequestAlpha1 = {
  encode(message: SubscribeTopicEventsRequestAlpha1, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.initialRequest !== undefined) {
      SubscribeTopicEventsInitialRequestAlpha1.encode(message.initialRequest, writer.uint32(10).fork()).ldelim();
    }
    if (message.eventResponse !== undefined) {
      SubscribeTopicEventsResponseAlpha1.encode(message.eventResponse, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubscribeTopicEventsRequestAlpha1 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeTopicEventsRequestAlpha1();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.initialRequest = SubscribeTopicEventsInitialRequestAlpha1.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventResponse = SubscribeTopicEventsResponseAlpha1.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeTopicEventsRequestAlpha1 {
    return {
      initialRequest: isSet(object.initialRequest)
        ? SubscribeTopicEventsInitialRequestAlpha1.fromJSON(object.initialRequest)
        : undefined,
      eventResponse: isSet(object.eventResponse)
        ? SubscribeTopicEventsResponseAlpha1.fromJSON(object.eventResponse)
        : undefined,
    };
  },

  toJSON(message: SubscribeTopicEventsRequestAlpha1): unknown {
    const obj: any = {};
    if (message.initialRequest !== undefined) {
      obj.initialRequest = SubscribeTopicEventsInitialRequestAlpha1.toJSON(message.initialRequest);
    }
    if (message.eventResponse !== undefined) {
      obj.eventResponse = SubscribeTopicEventsResponseAlpha1.toJSON(message.eventResponse);
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribeTopicEventsRequestAlpha1>): SubscribeTopicEventsRequestAlpha1 {
    return SubscribeTopicEventsRequestAlpha1.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeTopicEventsRequestAlpha1>): SubscribeTopicEventsRequestAlpha1 {
    const message = createBaseSubscribeTopicEventsRequestAlpha1();
    message.initialRequest = (object.initialRequest !== undefined && object.initialRequest !== null)
      ? SubscribeTopicEventsInitialRequestAlpha1.fromPartial(object.initialRequest)
      : undefined;
    message.eventResponse = (object.eventResponse !== undefined && object.eventResponse !== null)
      ? SubscribeTopicEventsResponseAlpha1.fromPartial(object.eventResponse)
      : undefined;
    return message;
  },
};

function createBaseSubscribeTopicEventsInitialRequestAlpha1(): SubscribeTopicEventsInitialRequestAlpha1 {
  return { pubsubName: "", topic: "", metadata: {}, deadLetterTopic: undefined };
}

export const SubscribeTopicEventsInitialRequestAlpha1 = {
  encode(message: SubscribeTopicEventsInitialRequestAlpha1, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pubsubName !== "") {
      writer.uint32(10).string(message.pubsubName);
    }
    if (message.topic !== "") {
      writer.uint32(18).string(message.topic);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      SubscribeTopicEventsInitialRequestAlpha1_MetadataEntry.encode(
        { key: key as any, value },
        writer.uint32(26).fork(),
      ).ldelim();
    });
    if (message.deadLetterTopic !== undefined) {
      writer.uint32(34).string(message.deadLetterTopic);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubscribeTopicEventsInitialRequestAlpha1 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeTopicEventsInitialRequestAlpha1();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pubsubName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = SubscribeTopicEventsInitialRequestAlpha1_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.deadLetterTopic = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeTopicEventsInitialRequestAlpha1 {
    return {
      pubsubName: isSet(object.pubsubName) ? globalThis.String(object.pubsubName) : "",
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      deadLetterTopic: isSet(object.deadLetterTopic) ? globalThis.String(object.deadLetterTopic) : undefined,
    };
  },

  toJSON(message: SubscribeTopicEventsInitialRequestAlpha1): unknown {
    const obj: any = {};
    if (message.pubsubName !== "") {
      obj.pubsubName = message.pubsubName;
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.deadLetterTopic !== undefined) {
      obj.deadLetterTopic = message.deadLetterTopic;
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribeTopicEventsInitialRequestAlpha1>): SubscribeTopicEventsInitialRequestAlpha1 {
    return SubscribeTopicEventsInitialRequestAlpha1.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeTopicEventsInitialRequestAlpha1>): SubscribeTopicEventsInitialRequestAlpha1 {
    const message = createBaseSubscribeTopicEventsInitialRequestAlpha1();
    message.pubsubName = object.pubsubName ?? "";
    message.topic = object.topic ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.deadLetterTopic = object.deadLetterTopic ?? undefined;
    return message;
  },
};

function createBaseSubscribeTopicEventsInitialRequestAlpha1_MetadataEntry(): SubscribeTopicEventsInitialRequestAlpha1_MetadataEntry {
  return { key: "", value: "" };
}

export const SubscribeTopicEventsInitialRequestAlpha1_MetadataEntry = {
  encode(
    message: SubscribeTopicEventsInitialRequestAlpha1_MetadataEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubscribeTopicEventsInitialRequestAlpha1_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeTopicEventsInitialRequestAlpha1_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeTopicEventsInitialRequestAlpha1_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SubscribeTopicEventsInitialRequestAlpha1_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<SubscribeTopicEventsInitialRequestAlpha1_MetadataEntry>,
  ): SubscribeTopicEventsInitialRequestAlpha1_MetadataEntry {
    return SubscribeTopicEventsInitialRequestAlpha1_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SubscribeTopicEventsInitialRequestAlpha1_MetadataEntry>,
  ): SubscribeTopicEventsInitialRequestAlpha1_MetadataEntry {
    const message = createBaseSubscribeTopicEventsInitialRequestAlpha1_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSubscribeTopicEventsResponseAlpha1(): SubscribeTopicEventsResponseAlpha1 {
  return { id: "", status: undefined };
}

export const SubscribeTopicEventsResponseAlpha1 = {
  encode(message: SubscribeTopicEventsResponseAlpha1, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== undefined) {
      TopicEventResponse.encode(message.status, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubscribeTopicEventsResponseAlpha1 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeTopicEventsResponseAlpha1();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = TopicEventResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeTopicEventsResponseAlpha1 {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? TopicEventResponse.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: SubscribeTopicEventsResponseAlpha1): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== undefined) {
      obj.status = TopicEventResponse.toJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribeTopicEventsResponseAlpha1>): SubscribeTopicEventsResponseAlpha1 {
    return SubscribeTopicEventsResponseAlpha1.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeTopicEventsResponseAlpha1>): SubscribeTopicEventsResponseAlpha1 {
    const message = createBaseSubscribeTopicEventsResponseAlpha1();
    message.id = object.id ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? TopicEventResponse.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseInvokeBindingRequest(): InvokeBindingRequest {
  return { name: "", data: new Uint8Array(0), metadata: {}, operation: "" };
}

export const InvokeBindingRequest = {
  encode(message: InvokeBindingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      InvokeBindingRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.operation !== "") {
      writer.uint32(34).string(message.operation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeBindingRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeBindingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = InvokeBindingRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.operation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeBindingRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      operation: isSet(object.operation) ? globalThis.String(object.operation) : "",
    };
  },

  toJSON(message: InvokeBindingRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeBindingRequest>): InvokeBindingRequest {
    return InvokeBindingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeBindingRequest>): InvokeBindingRequest {
    const message = createBaseInvokeBindingRequest();
    message.name = object.name ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.operation = object.operation ?? "";
    return message;
  },
};

function createBaseInvokeBindingRequest_MetadataEntry(): InvokeBindingRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const InvokeBindingRequest_MetadataEntry = {
  encode(message: InvokeBindingRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeBindingRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeBindingRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeBindingRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: InvokeBindingRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeBindingRequest_MetadataEntry>): InvokeBindingRequest_MetadataEntry {
    return InvokeBindingRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeBindingRequest_MetadataEntry>): InvokeBindingRequest_MetadataEntry {
    const message = createBaseInvokeBindingRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseInvokeBindingResponse(): InvokeBindingResponse {
  return { data: new Uint8Array(0), metadata: {} };
}

export const InvokeBindingResponse = {
  encode(message: InvokeBindingResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      InvokeBindingResponse_MetadataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeBindingResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeBindingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = InvokeBindingResponse_MetadataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metadata[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeBindingResponse {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: InvokeBindingResponse): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeBindingResponse>): InvokeBindingResponse {
    return InvokeBindingResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeBindingResponse>): InvokeBindingResponse {
    const message = createBaseInvokeBindingResponse();
    message.data = object.data ?? new Uint8Array(0);
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseInvokeBindingResponse_MetadataEntry(): InvokeBindingResponse_MetadataEntry {
  return { key: "", value: "" };
}

export const InvokeBindingResponse_MetadataEntry = {
  encode(message: InvokeBindingResponse_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeBindingResponse_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeBindingResponse_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeBindingResponse_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: InvokeBindingResponse_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeBindingResponse_MetadataEntry>): InvokeBindingResponse_MetadataEntry {
    return InvokeBindingResponse_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeBindingResponse_MetadataEntry>): InvokeBindingResponse_MetadataEntry {
    const message = createBaseInvokeBindingResponse_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetSecretRequest(): GetSecretRequest {
  return { storeName: "", key: "", metadata: {} };
}

export const GetSecretRequest = {
  encode(message: GetSecretRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.storeName !== "") {
      writer.uint32(10).string(message.storeName);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      GetSecretRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSecretRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSecretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = GetSecretRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSecretRequest {
    return {
      storeName: isSet(object.storeName) ? globalThis.String(object.storeName) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetSecretRequest): unknown {
    const obj: any = {};
    if (message.storeName !== "") {
      obj.storeName = message.storeName;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetSecretRequest>): GetSecretRequest {
    return GetSecretRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSecretRequest>): GetSecretRequest {
    const message = createBaseGetSecretRequest();
    message.storeName = object.storeName ?? "";
    message.key = object.key ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetSecretRequest_MetadataEntry(): GetSecretRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const GetSecretRequest_MetadataEntry = {
  encode(message: GetSecretRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSecretRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSecretRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSecretRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetSecretRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSecretRequest_MetadataEntry>): GetSecretRequest_MetadataEntry {
    return GetSecretRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSecretRequest_MetadataEntry>): GetSecretRequest_MetadataEntry {
    const message = createBaseGetSecretRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetSecretResponse(): GetSecretResponse {
  return { data: {} };
}

export const GetSecretResponse = {
  encode(message: GetSecretResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.data).forEach(([key, value]) => {
      GetSecretResponse_DataEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSecretResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSecretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = GetSecretResponse_DataEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.data[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSecretResponse {
    return {
      data: isObject(object.data)
        ? Object.entries(object.data).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetSecretResponse): unknown {
    const obj: any = {};
    if (message.data) {
      const entries = Object.entries(message.data);
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetSecretResponse>): GetSecretResponse {
    return GetSecretResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSecretResponse>): GetSecretResponse {
    const message = createBaseGetSecretResponse();
    message.data = Object.entries(object.data ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetSecretResponse_DataEntry(): GetSecretResponse_DataEntry {
  return { key: "", value: "" };
}

export const GetSecretResponse_DataEntry = {
  encode(message: GetSecretResponse_DataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSecretResponse_DataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSecretResponse_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSecretResponse_DataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetSecretResponse_DataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSecretResponse_DataEntry>): GetSecretResponse_DataEntry {
    return GetSecretResponse_DataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSecretResponse_DataEntry>): GetSecretResponse_DataEntry {
    const message = createBaseGetSecretResponse_DataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetBulkSecretRequest(): GetBulkSecretRequest {
  return { storeName: "", metadata: {} };
}

export const GetBulkSecretRequest = {
  encode(message: GetBulkSecretRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.storeName !== "") {
      writer.uint32(10).string(message.storeName);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      GetBulkSecretRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBulkSecretRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBulkSecretRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = GetBulkSecretRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metadata[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBulkSecretRequest {
    return {
      storeName: isSet(object.storeName) ? globalThis.String(object.storeName) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetBulkSecretRequest): unknown {
    const obj: any = {};
    if (message.storeName !== "") {
      obj.storeName = message.storeName;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetBulkSecretRequest>): GetBulkSecretRequest {
    return GetBulkSecretRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBulkSecretRequest>): GetBulkSecretRequest {
    const message = createBaseGetBulkSecretRequest();
    message.storeName = object.storeName ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetBulkSecretRequest_MetadataEntry(): GetBulkSecretRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const GetBulkSecretRequest_MetadataEntry = {
  encode(message: GetBulkSecretRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBulkSecretRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBulkSecretRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBulkSecretRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetBulkSecretRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBulkSecretRequest_MetadataEntry>): GetBulkSecretRequest_MetadataEntry {
    return GetBulkSecretRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBulkSecretRequest_MetadataEntry>): GetBulkSecretRequest_MetadataEntry {
    const message = createBaseGetBulkSecretRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSecretResponse(): SecretResponse {
  return { secrets: {} };
}

export const SecretResponse = {
  encode(message: SecretResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.secrets).forEach(([key, value]) => {
      SecretResponse_SecretsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SecretResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = SecretResponse_SecretsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.secrets[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretResponse {
    return {
      secrets: isObject(object.secrets)
        ? Object.entries(object.secrets).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SecretResponse): unknown {
    const obj: any = {};
    if (message.secrets) {
      const entries = Object.entries(message.secrets);
      if (entries.length > 0) {
        obj.secrets = {};
        entries.forEach(([k, v]) => {
          obj.secrets[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SecretResponse>): SecretResponse {
    return SecretResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SecretResponse>): SecretResponse {
    const message = createBaseSecretResponse();
    message.secrets = Object.entries(object.secrets ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSecretResponse_SecretsEntry(): SecretResponse_SecretsEntry {
  return { key: "", value: "" };
}

export const SecretResponse_SecretsEntry = {
  encode(message: SecretResponse_SecretsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SecretResponse_SecretsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecretResponse_SecretsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecretResponse_SecretsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SecretResponse_SecretsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SecretResponse_SecretsEntry>): SecretResponse_SecretsEntry {
    return SecretResponse_SecretsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SecretResponse_SecretsEntry>): SecretResponse_SecretsEntry {
    const message = createBaseSecretResponse_SecretsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetBulkSecretResponse(): GetBulkSecretResponse {
  return { data: {} };
}

export const GetBulkSecretResponse = {
  encode(message: GetBulkSecretResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.data).forEach(([key, value]) => {
      GetBulkSecretResponse_DataEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBulkSecretResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBulkSecretResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = GetBulkSecretResponse_DataEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.data[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBulkSecretResponse {
    return {
      data: isObject(object.data)
        ? Object.entries(object.data).reduce<{ [key: string]: SecretResponse }>((acc, [key, value]) => {
          acc[key] = SecretResponse.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetBulkSecretResponse): unknown {
    const obj: any = {};
    if (message.data) {
      const entries = Object.entries(message.data);
      if (entries.length > 0) {
        obj.data = {};
        entries.forEach(([k, v]) => {
          obj.data[k] = SecretResponse.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetBulkSecretResponse>): GetBulkSecretResponse {
    return GetBulkSecretResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBulkSecretResponse>): GetBulkSecretResponse {
    const message = createBaseGetBulkSecretResponse();
    message.data = Object.entries(object.data ?? {}).reduce<{ [key: string]: SecretResponse }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SecretResponse.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetBulkSecretResponse_DataEntry(): GetBulkSecretResponse_DataEntry {
  return { key: "", value: undefined };
}

export const GetBulkSecretResponse_DataEntry = {
  encode(message: GetBulkSecretResponse_DataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SecretResponse.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBulkSecretResponse_DataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBulkSecretResponse_DataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = SecretResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBulkSecretResponse_DataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SecretResponse.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetBulkSecretResponse_DataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SecretResponse.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<GetBulkSecretResponse_DataEntry>): GetBulkSecretResponse_DataEntry {
    return GetBulkSecretResponse_DataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBulkSecretResponse_DataEntry>): GetBulkSecretResponse_DataEntry {
    const message = createBaseGetBulkSecretResponse_DataEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SecretResponse.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseTransactionalStateOperation(): TransactionalStateOperation {
  return { operationType: "", request: undefined };
}

export const TransactionalStateOperation = {
  encode(message: TransactionalStateOperation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operationType !== "") {
      writer.uint32(10).string(message.operationType);
    }
    if (message.request !== undefined) {
      StateItem.encode(message.request, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionalStateOperation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionalStateOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operationType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.request = StateItem.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionalStateOperation {
    return {
      operationType: isSet(object.operationType) ? globalThis.String(object.operationType) : "",
      request: isSet(object.request) ? StateItem.fromJSON(object.request) : undefined,
    };
  },

  toJSON(message: TransactionalStateOperation): unknown {
    const obj: any = {};
    if (message.operationType !== "") {
      obj.operationType = message.operationType;
    }
    if (message.request !== undefined) {
      obj.request = StateItem.toJSON(message.request);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionalStateOperation>): TransactionalStateOperation {
    return TransactionalStateOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionalStateOperation>): TransactionalStateOperation {
    const message = createBaseTransactionalStateOperation();
    message.operationType = object.operationType ?? "";
    message.request = (object.request !== undefined && object.request !== null)
      ? StateItem.fromPartial(object.request)
      : undefined;
    return message;
  },
};

function createBaseExecuteStateTransactionRequest(): ExecuteStateTransactionRequest {
  return { storeName: "", operations: [], metadata: {} };
}

export const ExecuteStateTransactionRequest = {
  encode(message: ExecuteStateTransactionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.storeName !== "") {
      writer.uint32(10).string(message.storeName);
    }
    for (const v of message.operations) {
      TransactionalStateOperation.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ExecuteStateTransactionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork())
        .ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecuteStateTransactionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteStateTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operations.push(TransactionalStateOperation.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = ExecuteStateTransactionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteStateTransactionRequest {
    return {
      storeName: isSet(object.storeName) ? globalThis.String(object.storeName) : "",
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => TransactionalStateOperation.fromJSON(e))
        : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ExecuteStateTransactionRequest): unknown {
    const obj: any = {};
    if (message.storeName !== "") {
      obj.storeName = message.storeName;
    }
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => TransactionalStateOperation.toJSON(e));
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ExecuteStateTransactionRequest>): ExecuteStateTransactionRequest {
    return ExecuteStateTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecuteStateTransactionRequest>): ExecuteStateTransactionRequest {
    const message = createBaseExecuteStateTransactionRequest();
    message.storeName = object.storeName ?? "";
    message.operations = object.operations?.map((e) => TransactionalStateOperation.fromPartial(e)) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseExecuteStateTransactionRequest_MetadataEntry(): ExecuteStateTransactionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const ExecuteStateTransactionRequest_MetadataEntry = {
  encode(message: ExecuteStateTransactionRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecuteStateTransactionRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteStateTransactionRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteStateTransactionRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ExecuteStateTransactionRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ExecuteStateTransactionRequest_MetadataEntry>,
  ): ExecuteStateTransactionRequest_MetadataEntry {
    return ExecuteStateTransactionRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ExecuteStateTransactionRequest_MetadataEntry>,
  ): ExecuteStateTransactionRequest_MetadataEntry {
    const message = createBaseExecuteStateTransactionRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRegisterActorTimerRequest(): RegisterActorTimerRequest {
  return {
    actorType: "",
    actorId: "",
    name: "",
    dueTime: "",
    period: "",
    callback: "",
    data: new Uint8Array(0),
    ttl: "",
  };
}

export const RegisterActorTimerRequest = {
  encode(message: RegisterActorTimerRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.actorType !== "") {
      writer.uint32(10).string(message.actorType);
    }
    if (message.actorId !== "") {
      writer.uint32(18).string(message.actorId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.dueTime !== "") {
      writer.uint32(34).string(message.dueTime);
    }
    if (message.period !== "") {
      writer.uint32(42).string(message.period);
    }
    if (message.callback !== "") {
      writer.uint32(50).string(message.callback);
    }
    if (message.data.length !== 0) {
      writer.uint32(58).bytes(message.data);
    }
    if (message.ttl !== "") {
      writer.uint32(66).string(message.ttl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegisterActorTimerRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterActorTimerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actorType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.actorId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dueTime = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.period = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.callback = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.ttl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterActorTimerRequest {
    return {
      actorType: isSet(object.actorType) ? globalThis.String(object.actorType) : "",
      actorId: isSet(object.actorId) ? globalThis.String(object.actorId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dueTime: isSet(object.dueTime) ? globalThis.String(object.dueTime) : "",
      period: isSet(object.period) ? globalThis.String(object.period) : "",
      callback: isSet(object.callback) ? globalThis.String(object.callback) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      ttl: isSet(object.ttl) ? globalThis.String(object.ttl) : "",
    };
  },

  toJSON(message: RegisterActorTimerRequest): unknown {
    const obj: any = {};
    if (message.actorType !== "") {
      obj.actorType = message.actorType;
    }
    if (message.actorId !== "") {
      obj.actorId = message.actorId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dueTime !== "") {
      obj.dueTime = message.dueTime;
    }
    if (message.period !== "") {
      obj.period = message.period;
    }
    if (message.callback !== "") {
      obj.callback = message.callback;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.ttl !== "") {
      obj.ttl = message.ttl;
    }
    return obj;
  },

  create(base?: DeepPartial<RegisterActorTimerRequest>): RegisterActorTimerRequest {
    return RegisterActorTimerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegisterActorTimerRequest>): RegisterActorTimerRequest {
    const message = createBaseRegisterActorTimerRequest();
    message.actorType = object.actorType ?? "";
    message.actorId = object.actorId ?? "";
    message.name = object.name ?? "";
    message.dueTime = object.dueTime ?? "";
    message.period = object.period ?? "";
    message.callback = object.callback ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.ttl = object.ttl ?? "";
    return message;
  },
};

function createBaseUnregisterActorTimerRequest(): UnregisterActorTimerRequest {
  return { actorType: "", actorId: "", name: "" };
}

export const UnregisterActorTimerRequest = {
  encode(message: UnregisterActorTimerRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.actorType !== "") {
      writer.uint32(10).string(message.actorType);
    }
    if (message.actorId !== "") {
      writer.uint32(18).string(message.actorId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UnregisterActorTimerRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnregisterActorTimerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actorType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.actorId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnregisterActorTimerRequest {
    return {
      actorType: isSet(object.actorType) ? globalThis.String(object.actorType) : "",
      actorId: isSet(object.actorId) ? globalThis.String(object.actorId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: UnregisterActorTimerRequest): unknown {
    const obj: any = {};
    if (message.actorType !== "") {
      obj.actorType = message.actorType;
    }
    if (message.actorId !== "") {
      obj.actorId = message.actorId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<UnregisterActorTimerRequest>): UnregisterActorTimerRequest {
    return UnregisterActorTimerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnregisterActorTimerRequest>): UnregisterActorTimerRequest {
    const message = createBaseUnregisterActorTimerRequest();
    message.actorType = object.actorType ?? "";
    message.actorId = object.actorId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseRegisterActorReminderRequest(): RegisterActorReminderRequest {
  return { actorType: "", actorId: "", name: "", dueTime: "", period: "", data: new Uint8Array(0), ttl: "" };
}

export const RegisterActorReminderRequest = {
  encode(message: RegisterActorReminderRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.actorType !== "") {
      writer.uint32(10).string(message.actorType);
    }
    if (message.actorId !== "") {
      writer.uint32(18).string(message.actorId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.dueTime !== "") {
      writer.uint32(34).string(message.dueTime);
    }
    if (message.period !== "") {
      writer.uint32(42).string(message.period);
    }
    if (message.data.length !== 0) {
      writer.uint32(50).bytes(message.data);
    }
    if (message.ttl !== "") {
      writer.uint32(58).string(message.ttl);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegisterActorReminderRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterActorReminderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actorType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.actorId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dueTime = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.period = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ttl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterActorReminderRequest {
    return {
      actorType: isSet(object.actorType) ? globalThis.String(object.actorType) : "",
      actorId: isSet(object.actorId) ? globalThis.String(object.actorId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dueTime: isSet(object.dueTime) ? globalThis.String(object.dueTime) : "",
      period: isSet(object.period) ? globalThis.String(object.period) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      ttl: isSet(object.ttl) ? globalThis.String(object.ttl) : "",
    };
  },

  toJSON(message: RegisterActorReminderRequest): unknown {
    const obj: any = {};
    if (message.actorType !== "") {
      obj.actorType = message.actorType;
    }
    if (message.actorId !== "") {
      obj.actorId = message.actorId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dueTime !== "") {
      obj.dueTime = message.dueTime;
    }
    if (message.period !== "") {
      obj.period = message.period;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.ttl !== "") {
      obj.ttl = message.ttl;
    }
    return obj;
  },

  create(base?: DeepPartial<RegisterActorReminderRequest>): RegisterActorReminderRequest {
    return RegisterActorReminderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegisterActorReminderRequest>): RegisterActorReminderRequest {
    const message = createBaseRegisterActorReminderRequest();
    message.actorType = object.actorType ?? "";
    message.actorId = object.actorId ?? "";
    message.name = object.name ?? "";
    message.dueTime = object.dueTime ?? "";
    message.period = object.period ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.ttl = object.ttl ?? "";
    return message;
  },
};

function createBaseUnregisterActorReminderRequest(): UnregisterActorReminderRequest {
  return { actorType: "", actorId: "", name: "" };
}

export const UnregisterActorReminderRequest = {
  encode(message: UnregisterActorReminderRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.actorType !== "") {
      writer.uint32(10).string(message.actorType);
    }
    if (message.actorId !== "") {
      writer.uint32(18).string(message.actorId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UnregisterActorReminderRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnregisterActorReminderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actorType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.actorId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnregisterActorReminderRequest {
    return {
      actorType: isSet(object.actorType) ? globalThis.String(object.actorType) : "",
      actorId: isSet(object.actorId) ? globalThis.String(object.actorId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: UnregisterActorReminderRequest): unknown {
    const obj: any = {};
    if (message.actorType !== "") {
      obj.actorType = message.actorType;
    }
    if (message.actorId !== "") {
      obj.actorId = message.actorId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<UnregisterActorReminderRequest>): UnregisterActorReminderRequest {
    return UnregisterActorReminderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnregisterActorReminderRequest>): UnregisterActorReminderRequest {
    const message = createBaseUnregisterActorReminderRequest();
    message.actorType = object.actorType ?? "";
    message.actorId = object.actorId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetActorStateRequest(): GetActorStateRequest {
  return { actorType: "", actorId: "", key: "" };
}

export const GetActorStateRequest = {
  encode(message: GetActorStateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.actorType !== "") {
      writer.uint32(10).string(message.actorType);
    }
    if (message.actorId !== "") {
      writer.uint32(18).string(message.actorId);
    }
    if (message.key !== "") {
      writer.uint32(26).string(message.key);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetActorStateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActorStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actorType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.actorId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.key = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActorStateRequest {
    return {
      actorType: isSet(object.actorType) ? globalThis.String(object.actorType) : "",
      actorId: isSet(object.actorId) ? globalThis.String(object.actorId) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: GetActorStateRequest): unknown {
    const obj: any = {};
    if (message.actorType !== "") {
      obj.actorType = message.actorType;
    }
    if (message.actorId !== "") {
      obj.actorId = message.actorId;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create(base?: DeepPartial<GetActorStateRequest>): GetActorStateRequest {
    return GetActorStateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetActorStateRequest>): GetActorStateRequest {
    const message = createBaseGetActorStateRequest();
    message.actorType = object.actorType ?? "";
    message.actorId = object.actorId ?? "";
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseGetActorStateResponse(): GetActorStateResponse {
  return { data: new Uint8Array(0), metadata: {} };
}

export const GetActorStateResponse = {
  encode(message: GetActorStateResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      GetActorStateResponse_MetadataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetActorStateResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActorStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = GetActorStateResponse_MetadataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metadata[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActorStateResponse {
    return {
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetActorStateResponse): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetActorStateResponse>): GetActorStateResponse {
    return GetActorStateResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetActorStateResponse>): GetActorStateResponse {
    const message = createBaseGetActorStateResponse();
    message.data = object.data ?? new Uint8Array(0);
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetActorStateResponse_MetadataEntry(): GetActorStateResponse_MetadataEntry {
  return { key: "", value: "" };
}

export const GetActorStateResponse_MetadataEntry = {
  encode(message: GetActorStateResponse_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetActorStateResponse_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActorStateResponse_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActorStateResponse_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetActorStateResponse_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GetActorStateResponse_MetadataEntry>): GetActorStateResponse_MetadataEntry {
    return GetActorStateResponse_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetActorStateResponse_MetadataEntry>): GetActorStateResponse_MetadataEntry {
    const message = createBaseGetActorStateResponse_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseExecuteActorStateTransactionRequest(): ExecuteActorStateTransactionRequest {
  return { actorType: "", actorId: "", operations: [] };
}

export const ExecuteActorStateTransactionRequest = {
  encode(message: ExecuteActorStateTransactionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.actorType !== "") {
      writer.uint32(10).string(message.actorType);
    }
    if (message.actorId !== "") {
      writer.uint32(18).string(message.actorId);
    }
    for (const v of message.operations) {
      TransactionalActorStateOperation.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExecuteActorStateTransactionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteActorStateTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actorType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.actorId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.operations.push(TransactionalActorStateOperation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteActorStateTransactionRequest {
    return {
      actorType: isSet(object.actorType) ? globalThis.String(object.actorType) : "",
      actorId: isSet(object.actorId) ? globalThis.String(object.actorId) : "",
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => TransactionalActorStateOperation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ExecuteActorStateTransactionRequest): unknown {
    const obj: any = {};
    if (message.actorType !== "") {
      obj.actorType = message.actorType;
    }
    if (message.actorId !== "") {
      obj.actorId = message.actorId;
    }
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => TransactionalActorStateOperation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ExecuteActorStateTransactionRequest>): ExecuteActorStateTransactionRequest {
    return ExecuteActorStateTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecuteActorStateTransactionRequest>): ExecuteActorStateTransactionRequest {
    const message = createBaseExecuteActorStateTransactionRequest();
    message.actorType = object.actorType ?? "";
    message.actorId = object.actorId ?? "";
    message.operations = object.operations?.map((e) => TransactionalActorStateOperation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransactionalActorStateOperation(): TransactionalActorStateOperation {
  return { operationType: "", key: "", value: undefined, metadata: {} };
}

export const TransactionalActorStateOperation = {
  encode(message: TransactionalActorStateOperation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operationType !== "") {
      writer.uint32(10).string(message.operationType);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      TransactionalActorStateOperation_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork())
        .ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionalActorStateOperation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionalActorStateOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operationType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = TransactionalActorStateOperation_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionalActorStateOperation {
    return {
      operationType: isSet(object.operationType) ? globalThis.String(object.operationType) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Any.fromJSON(object.value) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TransactionalActorStateOperation): unknown {
    const obj: any = {};
    if (message.operationType !== "") {
      obj.operationType = message.operationType;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionalActorStateOperation>): TransactionalActorStateOperation {
    return TransactionalActorStateOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionalActorStateOperation>): TransactionalActorStateOperation {
    const message = createBaseTransactionalActorStateOperation();
    message.operationType = object.operationType ?? "";
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Any.fromPartial(object.value) : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTransactionalActorStateOperation_MetadataEntry(): TransactionalActorStateOperation_MetadataEntry {
  return { key: "", value: "" };
}

export const TransactionalActorStateOperation_MetadataEntry = {
  encode(
    message: TransactionalActorStateOperation_MetadataEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionalActorStateOperation_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionalActorStateOperation_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionalActorStateOperation_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TransactionalActorStateOperation_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<TransactionalActorStateOperation_MetadataEntry>,
  ): TransactionalActorStateOperation_MetadataEntry {
    return TransactionalActorStateOperation_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<TransactionalActorStateOperation_MetadataEntry>,
  ): TransactionalActorStateOperation_MetadataEntry {
    const message = createBaseTransactionalActorStateOperation_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseInvokeActorRequest(): InvokeActorRequest {
  return { actorType: "", actorId: "", method: "", data: new Uint8Array(0), metadata: {} };
}

export const InvokeActorRequest = {
  encode(message: InvokeActorRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.actorType !== "") {
      writer.uint32(10).string(message.actorType);
    }
    if (message.actorId !== "") {
      writer.uint32(18).string(message.actorId);
    }
    if (message.method !== "") {
      writer.uint32(26).string(message.method);
    }
    if (message.data.length !== 0) {
      writer.uint32(34).bytes(message.data);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      InvokeActorRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeActorRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeActorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.actorType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.actorId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.method = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = InvokeActorRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeActorRequest {
    return {
      actorType: isSet(object.actorType) ? globalThis.String(object.actorType) : "",
      actorId: isSet(object.actorId) ? globalThis.String(object.actorId) : "",
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: InvokeActorRequest): unknown {
    const obj: any = {};
    if (message.actorType !== "") {
      obj.actorType = message.actorType;
    }
    if (message.actorId !== "") {
      obj.actorId = message.actorId;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeActorRequest>): InvokeActorRequest {
    return InvokeActorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeActorRequest>): InvokeActorRequest {
    const message = createBaseInvokeActorRequest();
    message.actorType = object.actorType ?? "";
    message.actorId = object.actorId ?? "";
    message.method = object.method ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseInvokeActorRequest_MetadataEntry(): InvokeActorRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const InvokeActorRequest_MetadataEntry = {
  encode(message: InvokeActorRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeActorRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeActorRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeActorRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: InvokeActorRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeActorRequest_MetadataEntry>): InvokeActorRequest_MetadataEntry {
    return InvokeActorRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeActorRequest_MetadataEntry>): InvokeActorRequest_MetadataEntry {
    const message = createBaseInvokeActorRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseInvokeActorResponse(): InvokeActorResponse {
  return { data: new Uint8Array(0) };
}

export const InvokeActorResponse = {
  encode(message: InvokeActorResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InvokeActorResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvokeActorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvokeActorResponse {
    return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0) };
  },

  toJSON(message: InvokeActorResponse): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<InvokeActorResponse>): InvokeActorResponse {
    return InvokeActorResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvokeActorResponse>): InvokeActorResponse {
    const message = createBaseInvokeActorResponse();
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetMetadataRequest(): GetMetadataRequest {
  return {};
}

export const GetMetadataRequest = {
  encode(_: GetMetadataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMetadataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetMetadataRequest {
    return {};
  },

  toJSON(_: GetMetadataRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GetMetadataRequest>): GetMetadataRequest {
    return GetMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetMetadataRequest>): GetMetadataRequest {
    const message = createBaseGetMetadataRequest();
    return message;
  },
};

function createBaseGetMetadataResponse(): GetMetadataResponse {
  return {
    id: "",
    activeActorsCount: [],
    registeredComponents: [],
    extendedMetadata: {},
    subscriptions: [],
    httpEndpoints: [],
    appConnectionProperties: undefined,
    runtimeVersion: "",
    enabledFeatures: [],
    actorRuntime: undefined,
  };
}

export const GetMetadataResponse = {
  encode(message: GetMetadataResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.activeActorsCount) {
      ActiveActorsCount.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.registeredComponents) {
      RegisteredComponents.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    Object.entries(message.extendedMetadata).forEach(([key, value]) => {
      GetMetadataResponse_ExtendedMetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    for (const v of message.subscriptions) {
      PubsubSubscription.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.httpEndpoints) {
      MetadataHTTPEndpoint.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.appConnectionProperties !== undefined) {
      AppConnectionProperties.encode(message.appConnectionProperties, writer.uint32(58).fork()).ldelim();
    }
    if (message.runtimeVersion !== "") {
      writer.uint32(66).string(message.runtimeVersion);
    }
    for (const v of message.enabledFeatures) {
      writer.uint32(74).string(v!);
    }
    if (message.actorRuntime !== undefined) {
      ActorRuntime.encode(message.actorRuntime, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMetadataResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.activeActorsCount.push(ActiveActorsCount.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.registeredComponents.push(RegisteredComponents.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = GetMetadataResponse_ExtendedMetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.extendedMetadata[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.subscriptions.push(PubsubSubscription.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.httpEndpoints.push(MetadataHTTPEndpoint.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.appConnectionProperties = AppConnectionProperties.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.runtimeVersion = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.enabledFeatures.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.actorRuntime = ActorRuntime.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMetadataResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      activeActorsCount: globalThis.Array.isArray(object?.actors)
        ? object.actors.map((e: any) => ActiveActorsCount.fromJSON(e))
        : [],
      registeredComponents: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => RegisteredComponents.fromJSON(e))
        : [],
      extendedMetadata: isObject(object.extended)
        ? Object.entries(object.extended).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      subscriptions: globalThis.Array.isArray(object?.subscriptions)
        ? object.subscriptions.map((e: any) => PubsubSubscription.fromJSON(e))
        : [],
      httpEndpoints: globalThis.Array.isArray(object?.httpEndpoints)
        ? object.httpEndpoints.map((e: any) => MetadataHTTPEndpoint.fromJSON(e))
        : [],
      appConnectionProperties: isSet(object.appConnectionProperties)
        ? AppConnectionProperties.fromJSON(object.appConnectionProperties)
        : undefined,
      runtimeVersion: isSet(object.runtimeVersion) ? globalThis.String(object.runtimeVersion) : "",
      enabledFeatures: globalThis.Array.isArray(object?.enabledFeatures)
        ? object.enabledFeatures.map((e: any) => globalThis.String(e))
        : [],
      actorRuntime: isSet(object.actorRuntime) ? ActorRuntime.fromJSON(object.actorRuntime) : undefined,
    };
  },

  toJSON(message: GetMetadataResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.activeActorsCount?.length) {
      obj.actors = message.activeActorsCount.map((e) => ActiveActorsCount.toJSON(e));
    }
    if (message.registeredComponents?.length) {
      obj.components = message.registeredComponents.map((e) => RegisteredComponents.toJSON(e));
    }
    if (message.extendedMetadata) {
      const entries = Object.entries(message.extendedMetadata);
      if (entries.length > 0) {
        obj.extended = {};
        entries.forEach(([k, v]) => {
          obj.extended[k] = v;
        });
      }
    }
    if (message.subscriptions?.length) {
      obj.subscriptions = message.subscriptions.map((e) => PubsubSubscription.toJSON(e));
    }
    if (message.httpEndpoints?.length) {
      obj.httpEndpoints = message.httpEndpoints.map((e) => MetadataHTTPEndpoint.toJSON(e));
    }
    if (message.appConnectionProperties !== undefined) {
      obj.appConnectionProperties = AppConnectionProperties.toJSON(message.appConnectionProperties);
    }
    if (message.runtimeVersion !== "") {
      obj.runtimeVersion = message.runtimeVersion;
    }
    if (message.enabledFeatures?.length) {
      obj.enabledFeatures = message.enabledFeatures;
    }
    if (message.actorRuntime !== undefined) {
      obj.actorRuntime = ActorRuntime.toJSON(message.actorRuntime);
    }
    return obj;
  },

  create(base?: DeepPartial<GetMetadataResponse>): GetMetadataResponse {
    return GetMetadataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMetadataResponse>): GetMetadataResponse {
    const message = createBaseGetMetadataResponse();
    message.id = object.id ?? "";
    message.activeActorsCount = object.activeActorsCount?.map((e) => ActiveActorsCount.fromPartial(e)) || [];
    message.registeredComponents = object.registeredComponents?.map((e) => RegisteredComponents.fromPartial(e)) || [];
    message.extendedMetadata = Object.entries(object.extendedMetadata ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.subscriptions = object.subscriptions?.map((e) => PubsubSubscription.fromPartial(e)) || [];
    message.httpEndpoints = object.httpEndpoints?.map((e) => MetadataHTTPEndpoint.fromPartial(e)) || [];
    message.appConnectionProperties =
      (object.appConnectionProperties !== undefined && object.appConnectionProperties !== null)
        ? AppConnectionProperties.fromPartial(object.appConnectionProperties)
        : undefined;
    message.runtimeVersion = object.runtimeVersion ?? "";
    message.enabledFeatures = object.enabledFeatures?.map((e) => e) || [];
    message.actorRuntime = (object.actorRuntime !== undefined && object.actorRuntime !== null)
      ? ActorRuntime.fromPartial(object.actorRuntime)
      : undefined;
    return message;
  },
};

function createBaseGetMetadataResponse_ExtendedMetadataEntry(): GetMetadataResponse_ExtendedMetadataEntry {
  return { key: "", value: "" };
}

export const GetMetadataResponse_ExtendedMetadataEntry = {
  encode(message: GetMetadataResponse_ExtendedMetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetMetadataResponse_ExtendedMetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMetadataResponse_ExtendedMetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMetadataResponse_ExtendedMetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetMetadataResponse_ExtendedMetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GetMetadataResponse_ExtendedMetadataEntry>): GetMetadataResponse_ExtendedMetadataEntry {
    return GetMetadataResponse_ExtendedMetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetMetadataResponse_ExtendedMetadataEntry>,
  ): GetMetadataResponse_ExtendedMetadataEntry {
    const message = createBaseGetMetadataResponse_ExtendedMetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseActorRuntime(): ActorRuntime {
  return { runtimeStatus: 0, activeActors: [], hostReady: false, placement: "" };
}

export const ActorRuntime = {
  encode(message: ActorRuntime, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.runtimeStatus !== 0) {
      writer.uint32(8).int32(message.runtimeStatus);
    }
    for (const v of message.activeActors) {
      ActiveActorsCount.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.hostReady !== false) {
      writer.uint32(24).bool(message.hostReady);
    }
    if (message.placement !== "") {
      writer.uint32(34).string(message.placement);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ActorRuntime {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActorRuntime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.runtimeStatus = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.activeActors.push(ActiveActorsCount.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.hostReady = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.placement = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActorRuntime {
    return {
      runtimeStatus: isSet(object.runtimeStatus) ? actorRuntime_ActorRuntimeStatusFromJSON(object.runtimeStatus) : 0,
      activeActors: globalThis.Array.isArray(object?.activeActors)
        ? object.activeActors.map((e: any) => ActiveActorsCount.fromJSON(e))
        : [],
      hostReady: isSet(object.hostReady) ? globalThis.Boolean(object.hostReady) : false,
      placement: isSet(object.placement) ? globalThis.String(object.placement) : "",
    };
  },

  toJSON(message: ActorRuntime): unknown {
    const obj: any = {};
    if (message.runtimeStatus !== 0) {
      obj.runtimeStatus = actorRuntime_ActorRuntimeStatusToJSON(message.runtimeStatus);
    }
    if (message.activeActors?.length) {
      obj.activeActors = message.activeActors.map((e) => ActiveActorsCount.toJSON(e));
    }
    if (message.hostReady !== false) {
      obj.hostReady = message.hostReady;
    }
    if (message.placement !== "") {
      obj.placement = message.placement;
    }
    return obj;
  },

  create(base?: DeepPartial<ActorRuntime>): ActorRuntime {
    return ActorRuntime.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActorRuntime>): ActorRuntime {
    const message = createBaseActorRuntime();
    message.runtimeStatus = object.runtimeStatus ?? 0;
    message.activeActors = object.activeActors?.map((e) => ActiveActorsCount.fromPartial(e)) || [];
    message.hostReady = object.hostReady ?? false;
    message.placement = object.placement ?? "";
    return message;
  },
};

function createBaseActiveActorsCount(): ActiveActorsCount {
  return { type: "", count: 0 };
}

export const ActiveActorsCount = {
  encode(message: ActiveActorsCount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ActiveActorsCount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActiveActorsCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActiveActorsCount {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: ActiveActorsCount): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(base?: DeepPartial<ActiveActorsCount>): ActiveActorsCount {
    return ActiveActorsCount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActiveActorsCount>): ActiveActorsCount {
    const message = createBaseActiveActorsCount();
    message.type = object.type ?? "";
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseRegisteredComponents(): RegisteredComponents {
  return { name: "", type: "", version: "", capabilities: [] };
}

export const RegisteredComponents = {
  encode(message: RegisteredComponents, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    for (const v of message.capabilities) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegisteredComponents {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisteredComponents();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.capabilities.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisteredComponents {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      capabilities: globalThis.Array.isArray(object?.capabilities)
        ? object.capabilities.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: RegisteredComponents): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.capabilities?.length) {
      obj.capabilities = message.capabilities;
    }
    return obj;
  },

  create(base?: DeepPartial<RegisteredComponents>): RegisteredComponents {
    return RegisteredComponents.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegisteredComponents>): RegisteredComponents {
    const message = createBaseRegisteredComponents();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.version = object.version ?? "";
    message.capabilities = object.capabilities?.map((e) => e) || [];
    return message;
  },
};

function createBaseMetadataHTTPEndpoint(): MetadataHTTPEndpoint {
  return { name: "" };
}

export const MetadataHTTPEndpoint = {
  encode(message: MetadataHTTPEndpoint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetadataHTTPEndpoint {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataHTTPEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetadataHTTPEndpoint {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: MetadataHTTPEndpoint): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<MetadataHTTPEndpoint>): MetadataHTTPEndpoint {
    return MetadataHTTPEndpoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetadataHTTPEndpoint>): MetadataHTTPEndpoint {
    const message = createBaseMetadataHTTPEndpoint();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAppConnectionProperties(): AppConnectionProperties {
  return { port: 0, protocol: "", channelAddress: "", maxConcurrency: 0, health: undefined };
}

export const AppConnectionProperties = {
  encode(message: AppConnectionProperties, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.port !== 0) {
      writer.uint32(8).int32(message.port);
    }
    if (message.protocol !== "") {
      writer.uint32(18).string(message.protocol);
    }
    if (message.channelAddress !== "") {
      writer.uint32(26).string(message.channelAddress);
    }
    if (message.maxConcurrency !== 0) {
      writer.uint32(32).int32(message.maxConcurrency);
    }
    if (message.health !== undefined) {
      AppConnectionHealthProperties.encode(message.health, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AppConnectionProperties {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppConnectionProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.port = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.protocol = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channelAddress = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxConcurrency = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.health = AppConnectionHealthProperties.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppConnectionProperties {
    return {
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      protocol: isSet(object.protocol) ? globalThis.String(object.protocol) : "",
      channelAddress: isSet(object.channelAddress) ? globalThis.String(object.channelAddress) : "",
      maxConcurrency: isSet(object.maxConcurrency) ? globalThis.Number(object.maxConcurrency) : 0,
      health: isSet(object.health) ? AppConnectionHealthProperties.fromJSON(object.health) : undefined,
    };
  },

  toJSON(message: AppConnectionProperties): unknown {
    const obj: any = {};
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.protocol !== "") {
      obj.protocol = message.protocol;
    }
    if (message.channelAddress !== "") {
      obj.channelAddress = message.channelAddress;
    }
    if (message.maxConcurrency !== 0) {
      obj.maxConcurrency = Math.round(message.maxConcurrency);
    }
    if (message.health !== undefined) {
      obj.health = AppConnectionHealthProperties.toJSON(message.health);
    }
    return obj;
  },

  create(base?: DeepPartial<AppConnectionProperties>): AppConnectionProperties {
    return AppConnectionProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppConnectionProperties>): AppConnectionProperties {
    const message = createBaseAppConnectionProperties();
    message.port = object.port ?? 0;
    message.protocol = object.protocol ?? "";
    message.channelAddress = object.channelAddress ?? "";
    message.maxConcurrency = object.maxConcurrency ?? 0;
    message.health = (object.health !== undefined && object.health !== null)
      ? AppConnectionHealthProperties.fromPartial(object.health)
      : undefined;
    return message;
  },
};

function createBaseAppConnectionHealthProperties(): AppConnectionHealthProperties {
  return { healthCheckPath: "", healthProbeInterval: "", healthProbeTimeout: "", healthThreshold: 0 };
}

export const AppConnectionHealthProperties = {
  encode(message: AppConnectionHealthProperties, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.healthCheckPath !== "") {
      writer.uint32(10).string(message.healthCheckPath);
    }
    if (message.healthProbeInterval !== "") {
      writer.uint32(18).string(message.healthProbeInterval);
    }
    if (message.healthProbeTimeout !== "") {
      writer.uint32(26).string(message.healthProbeTimeout);
    }
    if (message.healthThreshold !== 0) {
      writer.uint32(32).int32(message.healthThreshold);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AppConnectionHealthProperties {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppConnectionHealthProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.healthCheckPath = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.healthProbeInterval = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.healthProbeTimeout = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.healthThreshold = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppConnectionHealthProperties {
    return {
      healthCheckPath: isSet(object.healthCheckPath) ? globalThis.String(object.healthCheckPath) : "",
      healthProbeInterval: isSet(object.healthProbeInterval) ? globalThis.String(object.healthProbeInterval) : "",
      healthProbeTimeout: isSet(object.healthProbeTimeout) ? globalThis.String(object.healthProbeTimeout) : "",
      healthThreshold: isSet(object.healthThreshold) ? globalThis.Number(object.healthThreshold) : 0,
    };
  },

  toJSON(message: AppConnectionHealthProperties): unknown {
    const obj: any = {};
    if (message.healthCheckPath !== "") {
      obj.healthCheckPath = message.healthCheckPath;
    }
    if (message.healthProbeInterval !== "") {
      obj.healthProbeInterval = message.healthProbeInterval;
    }
    if (message.healthProbeTimeout !== "") {
      obj.healthProbeTimeout = message.healthProbeTimeout;
    }
    if (message.healthThreshold !== 0) {
      obj.healthThreshold = Math.round(message.healthThreshold);
    }
    return obj;
  },

  create(base?: DeepPartial<AppConnectionHealthProperties>): AppConnectionHealthProperties {
    return AppConnectionHealthProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppConnectionHealthProperties>): AppConnectionHealthProperties {
    const message = createBaseAppConnectionHealthProperties();
    message.healthCheckPath = object.healthCheckPath ?? "";
    message.healthProbeInterval = object.healthProbeInterval ?? "";
    message.healthProbeTimeout = object.healthProbeTimeout ?? "";
    message.healthThreshold = object.healthThreshold ?? 0;
    return message;
  },
};

function createBasePubsubSubscription(): PubsubSubscription {
  return { pubsubName: "", topic: "", metadata: {}, rules: undefined, deadLetterTopic: "" };
}

export const PubsubSubscription = {
  encode(message: PubsubSubscription, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pubsubName !== "") {
      writer.uint32(10).string(message.pubsubName);
    }
    if (message.topic !== "") {
      writer.uint32(18).string(message.topic);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      PubsubSubscription_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.rules !== undefined) {
      PubsubSubscriptionRules.encode(message.rules, writer.uint32(34).fork()).ldelim();
    }
    if (message.deadLetterTopic !== "") {
      writer.uint32(42).string(message.deadLetterTopic);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PubsubSubscription {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubsubSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pubsubName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = PubsubSubscription_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rules = PubsubSubscriptionRules.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.deadLetterTopic = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubsubSubscription {
    return {
      pubsubName: isSet(object.pubsubname) ? globalThis.String(object.pubsubname) : "",
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      rules: isSet(object.rules) ? PubsubSubscriptionRules.fromJSON(object.rules) : undefined,
      deadLetterTopic: isSet(object.deadLetterTopic) ? globalThis.String(object.deadLetterTopic) : "",
    };
  },

  toJSON(message: PubsubSubscription): unknown {
    const obj: any = {};
    if (message.pubsubName !== "") {
      obj.pubsubname = message.pubsubName;
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.rules !== undefined) {
      obj.rules = PubsubSubscriptionRules.toJSON(message.rules);
    }
    if (message.deadLetterTopic !== "") {
      obj.deadLetterTopic = message.deadLetterTopic;
    }
    return obj;
  },

  create(base?: DeepPartial<PubsubSubscription>): PubsubSubscription {
    return PubsubSubscription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PubsubSubscription>): PubsubSubscription {
    const message = createBasePubsubSubscription();
    message.pubsubName = object.pubsubName ?? "";
    message.topic = object.topic ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.rules = (object.rules !== undefined && object.rules !== null)
      ? PubsubSubscriptionRules.fromPartial(object.rules)
      : undefined;
    message.deadLetterTopic = object.deadLetterTopic ?? "";
    return message;
  },
};

function createBasePubsubSubscription_MetadataEntry(): PubsubSubscription_MetadataEntry {
  return { key: "", value: "" };
}

export const PubsubSubscription_MetadataEntry = {
  encode(message: PubsubSubscription_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PubsubSubscription_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubsubSubscription_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubsubSubscription_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PubsubSubscription_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<PubsubSubscription_MetadataEntry>): PubsubSubscription_MetadataEntry {
    return PubsubSubscription_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PubsubSubscription_MetadataEntry>): PubsubSubscription_MetadataEntry {
    const message = createBasePubsubSubscription_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePubsubSubscriptionRules(): PubsubSubscriptionRules {
  return { rules: [] };
}

export const PubsubSubscriptionRules = {
  encode(message: PubsubSubscriptionRules, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.rules) {
      PubsubSubscriptionRule.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PubsubSubscriptionRules {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubsubSubscriptionRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rules.push(PubsubSubscriptionRule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubsubSubscriptionRules {
    return {
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => PubsubSubscriptionRule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PubsubSubscriptionRules): unknown {
    const obj: any = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => PubsubSubscriptionRule.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PubsubSubscriptionRules>): PubsubSubscriptionRules {
    return PubsubSubscriptionRules.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PubsubSubscriptionRules>): PubsubSubscriptionRules {
    const message = createBasePubsubSubscriptionRules();
    message.rules = object.rules?.map((e) => PubsubSubscriptionRule.fromPartial(e)) || [];
    return message;
  },
};

function createBasePubsubSubscriptionRule(): PubsubSubscriptionRule {
  return { match: "", path: "" };
}

export const PubsubSubscriptionRule = {
  encode(message: PubsubSubscriptionRule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.match !== "") {
      writer.uint32(10).string(message.match);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PubsubSubscriptionRule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubsubSubscriptionRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.match = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubsubSubscriptionRule {
    return {
      match: isSet(object.match) ? globalThis.String(object.match) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: PubsubSubscriptionRule): unknown {
    const obj: any = {};
    if (message.match !== "") {
      obj.match = message.match;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<PubsubSubscriptionRule>): PubsubSubscriptionRule {
    return PubsubSubscriptionRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PubsubSubscriptionRule>): PubsubSubscriptionRule {
    const message = createBasePubsubSubscriptionRule();
    message.match = object.match ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseSetMetadataRequest(): SetMetadataRequest {
  return { key: "", value: "" };
}

export const SetMetadataRequest = {
  encode(message: SetMetadataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetMetadataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetMetadataRequest {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SetMetadataRequest): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SetMetadataRequest>): SetMetadataRequest {
    return SetMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetMetadataRequest>): SetMetadataRequest {
    const message = createBaseSetMetadataRequest();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetConfigurationRequest(): GetConfigurationRequest {
  return { storeName: "", keys: [], metadata: {} };
}

export const GetConfigurationRequest = {
  encode(message: GetConfigurationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.storeName !== "") {
      writer.uint32(10).string(message.storeName);
    }
    for (const v of message.keys) {
      writer.uint32(18).string(v!);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      GetConfigurationRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetConfigurationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConfigurationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keys.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = GetConfigurationRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConfigurationRequest {
    return {
      storeName: isSet(object.storeName) ? globalThis.String(object.storeName) : "",
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => globalThis.String(e)) : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetConfigurationRequest): unknown {
    const obj: any = {};
    if (message.storeName !== "") {
      obj.storeName = message.storeName;
    }
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetConfigurationRequest>): GetConfigurationRequest {
    return GetConfigurationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConfigurationRequest>): GetConfigurationRequest {
    const message = createBaseGetConfigurationRequest();
    message.storeName = object.storeName ?? "";
    message.keys = object.keys?.map((e) => e) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetConfigurationRequest_MetadataEntry(): GetConfigurationRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const GetConfigurationRequest_MetadataEntry = {
  encode(message: GetConfigurationRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetConfigurationRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConfigurationRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConfigurationRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetConfigurationRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GetConfigurationRequest_MetadataEntry>): GetConfigurationRequest_MetadataEntry {
    return GetConfigurationRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConfigurationRequest_MetadataEntry>): GetConfigurationRequest_MetadataEntry {
    const message = createBaseGetConfigurationRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetConfigurationResponse(): GetConfigurationResponse {
  return { items: {} };
}

export const GetConfigurationResponse = {
  encode(message: GetConfigurationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.items).forEach(([key, value]) => {
      GetConfigurationResponse_ItemsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetConfigurationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConfigurationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = GetConfigurationResponse_ItemsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.items[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConfigurationResponse {
    return {
      items: isObject(object.items)
        ? Object.entries(object.items).reduce<{ [key: string]: ConfigurationItem }>((acc, [key, value]) => {
          acc[key] = ConfigurationItem.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetConfigurationResponse): unknown {
    const obj: any = {};
    if (message.items) {
      const entries = Object.entries(message.items);
      if (entries.length > 0) {
        obj.items = {};
        entries.forEach(([k, v]) => {
          obj.items[k] = ConfigurationItem.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetConfigurationResponse>): GetConfigurationResponse {
    return GetConfigurationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConfigurationResponse>): GetConfigurationResponse {
    const message = createBaseGetConfigurationResponse();
    message.items = Object.entries(object.items ?? {}).reduce<{ [key: string]: ConfigurationItem }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ConfigurationItem.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGetConfigurationResponse_ItemsEntry(): GetConfigurationResponse_ItemsEntry {
  return { key: "", value: undefined };
}

export const GetConfigurationResponse_ItemsEntry = {
  encode(message: GetConfigurationResponse_ItemsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ConfigurationItem.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetConfigurationResponse_ItemsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConfigurationResponse_ItemsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ConfigurationItem.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConfigurationResponse_ItemsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ConfigurationItem.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetConfigurationResponse_ItemsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ConfigurationItem.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<GetConfigurationResponse_ItemsEntry>): GetConfigurationResponse_ItemsEntry {
    return GetConfigurationResponse_ItemsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConfigurationResponse_ItemsEntry>): GetConfigurationResponse_ItemsEntry {
    const message = createBaseGetConfigurationResponse_ItemsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ConfigurationItem.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSubscribeConfigurationRequest(): SubscribeConfigurationRequest {
  return { storeName: "", keys: [], metadata: {} };
}

export const SubscribeConfigurationRequest = {
  encode(message: SubscribeConfigurationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.storeName !== "") {
      writer.uint32(10).string(message.storeName);
    }
    for (const v of message.keys) {
      writer.uint32(18).string(v!);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      SubscribeConfigurationRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubscribeConfigurationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeConfigurationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keys.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = SubscribeConfigurationRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeConfigurationRequest {
    return {
      storeName: isSet(object.storeName) ? globalThis.String(object.storeName) : "",
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => globalThis.String(e)) : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SubscribeConfigurationRequest): unknown {
    const obj: any = {};
    if (message.storeName !== "") {
      obj.storeName = message.storeName;
    }
    if (message.keys?.length) {
      obj.keys = message.keys;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribeConfigurationRequest>): SubscribeConfigurationRequest {
    return SubscribeConfigurationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeConfigurationRequest>): SubscribeConfigurationRequest {
    const message = createBaseSubscribeConfigurationRequest();
    message.storeName = object.storeName ?? "";
    message.keys = object.keys?.map((e) => e) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSubscribeConfigurationRequest_MetadataEntry(): SubscribeConfigurationRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const SubscribeConfigurationRequest_MetadataEntry = {
  encode(message: SubscribeConfigurationRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubscribeConfigurationRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeConfigurationRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeConfigurationRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SubscribeConfigurationRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribeConfigurationRequest_MetadataEntry>): SubscribeConfigurationRequest_MetadataEntry {
    return SubscribeConfigurationRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SubscribeConfigurationRequest_MetadataEntry>,
  ): SubscribeConfigurationRequest_MetadataEntry {
    const message = createBaseSubscribeConfigurationRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUnsubscribeConfigurationRequest(): UnsubscribeConfigurationRequest {
  return { storeName: "", id: "" };
}

export const UnsubscribeConfigurationRequest = {
  encode(message: UnsubscribeConfigurationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.storeName !== "") {
      writer.uint32(10).string(message.storeName);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UnsubscribeConfigurationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnsubscribeConfigurationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnsubscribeConfigurationRequest {
    return {
      storeName: isSet(object.storeName) ? globalThis.String(object.storeName) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: UnsubscribeConfigurationRequest): unknown {
    const obj: any = {};
    if (message.storeName !== "") {
      obj.storeName = message.storeName;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<UnsubscribeConfigurationRequest>): UnsubscribeConfigurationRequest {
    return UnsubscribeConfigurationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnsubscribeConfigurationRequest>): UnsubscribeConfigurationRequest {
    const message = createBaseUnsubscribeConfigurationRequest();
    message.storeName = object.storeName ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseSubscribeConfigurationResponse(): SubscribeConfigurationResponse {
  return { id: "", items: {} };
}

export const SubscribeConfigurationResponse = {
  encode(message: SubscribeConfigurationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    Object.entries(message.items).forEach(([key, value]) => {
      SubscribeConfigurationResponse_ItemsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubscribeConfigurationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeConfigurationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = SubscribeConfigurationResponse_ItemsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.items[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeConfigurationResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      items: isObject(object.items)
        ? Object.entries(object.items).reduce<{ [key: string]: ConfigurationItem }>((acc, [key, value]) => {
          acc[key] = ConfigurationItem.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SubscribeConfigurationResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.items) {
      const entries = Object.entries(message.items);
      if (entries.length > 0) {
        obj.items = {};
        entries.forEach(([k, v]) => {
          obj.items[k] = ConfigurationItem.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribeConfigurationResponse>): SubscribeConfigurationResponse {
    return SubscribeConfigurationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeConfigurationResponse>): SubscribeConfigurationResponse {
    const message = createBaseSubscribeConfigurationResponse();
    message.id = object.id ?? "";
    message.items = Object.entries(object.items ?? {}).reduce<{ [key: string]: ConfigurationItem }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ConfigurationItem.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSubscribeConfigurationResponse_ItemsEntry(): SubscribeConfigurationResponse_ItemsEntry {
  return { key: "", value: undefined };
}

export const SubscribeConfigurationResponse_ItemsEntry = {
  encode(message: SubscribeConfigurationResponse_ItemsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ConfigurationItem.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubscribeConfigurationResponse_ItemsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeConfigurationResponse_ItemsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ConfigurationItem.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeConfigurationResponse_ItemsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ConfigurationItem.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SubscribeConfigurationResponse_ItemsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ConfigurationItem.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribeConfigurationResponse_ItemsEntry>): SubscribeConfigurationResponse_ItemsEntry {
    return SubscribeConfigurationResponse_ItemsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SubscribeConfigurationResponse_ItemsEntry>,
  ): SubscribeConfigurationResponse_ItemsEntry {
    const message = createBaseSubscribeConfigurationResponse_ItemsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ConfigurationItem.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseUnsubscribeConfigurationResponse(): UnsubscribeConfigurationResponse {
  return { ok: false, message: "" };
}

export const UnsubscribeConfigurationResponse = {
  encode(message: UnsubscribeConfigurationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ok !== false) {
      writer.uint32(8).bool(message.ok);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UnsubscribeConfigurationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnsubscribeConfigurationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ok = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnsubscribeConfigurationResponse {
    return {
      ok: isSet(object.ok) ? globalThis.Boolean(object.ok) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: UnsubscribeConfigurationResponse): unknown {
    const obj: any = {};
    if (message.ok !== false) {
      obj.ok = message.ok;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<UnsubscribeConfigurationResponse>): UnsubscribeConfigurationResponse {
    return UnsubscribeConfigurationResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnsubscribeConfigurationResponse>): UnsubscribeConfigurationResponse {
    const message = createBaseUnsubscribeConfigurationResponse();
    message.ok = object.ok ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseTryLockRequest(): TryLockRequest {
  return { storeName: "", resourceId: "", lockOwner: "", expiryInSeconds: 0 };
}

export const TryLockRequest = {
  encode(message: TryLockRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.storeName !== "") {
      writer.uint32(10).string(message.storeName);
    }
    if (message.resourceId !== "") {
      writer.uint32(18).string(message.resourceId);
    }
    if (message.lockOwner !== "") {
      writer.uint32(26).string(message.lockOwner);
    }
    if (message.expiryInSeconds !== 0) {
      writer.uint32(32).int32(message.expiryInSeconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TryLockRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTryLockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lockOwner = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.expiryInSeconds = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TryLockRequest {
    return {
      storeName: isSet(object.storeName) ? globalThis.String(object.storeName) : "",
      resourceId: isSet(object.resourceId) ? globalThis.String(object.resourceId) : "",
      lockOwner: isSet(object.lockOwner) ? globalThis.String(object.lockOwner) : "",
      expiryInSeconds: isSet(object.expiryInSeconds) ? globalThis.Number(object.expiryInSeconds) : 0,
    };
  },

  toJSON(message: TryLockRequest): unknown {
    const obj: any = {};
    if (message.storeName !== "") {
      obj.storeName = message.storeName;
    }
    if (message.resourceId !== "") {
      obj.resourceId = message.resourceId;
    }
    if (message.lockOwner !== "") {
      obj.lockOwner = message.lockOwner;
    }
    if (message.expiryInSeconds !== 0) {
      obj.expiryInSeconds = Math.round(message.expiryInSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<TryLockRequest>): TryLockRequest {
    return TryLockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TryLockRequest>): TryLockRequest {
    const message = createBaseTryLockRequest();
    message.storeName = object.storeName ?? "";
    message.resourceId = object.resourceId ?? "";
    message.lockOwner = object.lockOwner ?? "";
    message.expiryInSeconds = object.expiryInSeconds ?? 0;
    return message;
  },
};

function createBaseTryLockResponse(): TryLockResponse {
  return { success: false };
}

export const TryLockResponse = {
  encode(message: TryLockResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TryLockResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTryLockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TryLockResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: TryLockResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create(base?: DeepPartial<TryLockResponse>): TryLockResponse {
    return TryLockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TryLockResponse>): TryLockResponse {
    const message = createBaseTryLockResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseUnlockRequest(): UnlockRequest {
  return { storeName: "", resourceId: "", lockOwner: "" };
}

export const UnlockRequest = {
  encode(message: UnlockRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.storeName !== "") {
      writer.uint32(10).string(message.storeName);
    }
    if (message.resourceId !== "") {
      writer.uint32(18).string(message.resourceId);
    }
    if (message.lockOwner !== "") {
      writer.uint32(26).string(message.lockOwner);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UnlockRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lockOwner = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnlockRequest {
    return {
      storeName: isSet(object.storeName) ? globalThis.String(object.storeName) : "",
      resourceId: isSet(object.resourceId) ? globalThis.String(object.resourceId) : "",
      lockOwner: isSet(object.lockOwner) ? globalThis.String(object.lockOwner) : "",
    };
  },

  toJSON(message: UnlockRequest): unknown {
    const obj: any = {};
    if (message.storeName !== "") {
      obj.storeName = message.storeName;
    }
    if (message.resourceId !== "") {
      obj.resourceId = message.resourceId;
    }
    if (message.lockOwner !== "") {
      obj.lockOwner = message.lockOwner;
    }
    return obj;
  },

  create(base?: DeepPartial<UnlockRequest>): UnlockRequest {
    return UnlockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnlockRequest>): UnlockRequest {
    const message = createBaseUnlockRequest();
    message.storeName = object.storeName ?? "";
    message.resourceId = object.resourceId ?? "";
    message.lockOwner = object.lockOwner ?? "";
    return message;
  },
};

function createBaseUnlockResponse(): UnlockResponse {
  return { status: 0 };
}

export const UnlockResponse = {
  encode(message: UnlockResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UnlockResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnlockResponse {
    return { status: isSet(object.status) ? unlockResponse_StatusFromJSON(object.status) : 0 };
  },

  toJSON(message: UnlockResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = unlockResponse_StatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<UnlockResponse>): UnlockResponse {
    return UnlockResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnlockResponse>): UnlockResponse {
    const message = createBaseUnlockResponse();
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseSubtleGetKeyRequest(): SubtleGetKeyRequest {
  return { componentName: "", name: "", format: 0 };
}

export const SubtleGetKeyRequest = {
  encode(message: SubtleGetKeyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.componentName !== "") {
      writer.uint32(10).string(message.componentName);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.format !== 0) {
      writer.uint32(24).int32(message.format);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtleGetKeyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtleGetKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.componentName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtleGetKeyRequest {
    return {
      componentName: isSet(object.componentName) ? globalThis.String(object.componentName) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      format: isSet(object.format) ? subtleGetKeyRequest_KeyFormatFromJSON(object.format) : 0,
    };
  },

  toJSON(message: SubtleGetKeyRequest): unknown {
    const obj: any = {};
    if (message.componentName !== "") {
      obj.componentName = message.componentName;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.format !== 0) {
      obj.format = subtleGetKeyRequest_KeyFormatToJSON(message.format);
    }
    return obj;
  },

  create(base?: DeepPartial<SubtleGetKeyRequest>): SubtleGetKeyRequest {
    return SubtleGetKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubtleGetKeyRequest>): SubtleGetKeyRequest {
    const message = createBaseSubtleGetKeyRequest();
    message.componentName = object.componentName ?? "";
    message.name = object.name ?? "";
    message.format = object.format ?? 0;
    return message;
  },
};

function createBaseSubtleGetKeyResponse(): SubtleGetKeyResponse {
  return { name: "", publicKey: "" };
}

export const SubtleGetKeyResponse = {
  encode(message: SubtleGetKeyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.publicKey !== "") {
      writer.uint32(18).string(message.publicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtleGetKeyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtleGetKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.publicKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtleGetKeyResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
    };
  },

  toJSON(message: SubtleGetKeyResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    return obj;
  },

  create(base?: DeepPartial<SubtleGetKeyResponse>): SubtleGetKeyResponse {
    return SubtleGetKeyResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubtleGetKeyResponse>): SubtleGetKeyResponse {
    const message = createBaseSubtleGetKeyResponse();
    message.name = object.name ?? "";
    message.publicKey = object.publicKey ?? "";
    return message;
  },
};

function createBaseSubtleEncryptRequest(): SubtleEncryptRequest {
  return {
    componentName: "",
    plaintext: new Uint8Array(0),
    algorithm: "",
    keyName: "",
    nonce: new Uint8Array(0),
    associatedData: new Uint8Array(0),
  };
}

export const SubtleEncryptRequest = {
  encode(message: SubtleEncryptRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.componentName !== "") {
      writer.uint32(10).string(message.componentName);
    }
    if (message.plaintext.length !== 0) {
      writer.uint32(18).bytes(message.plaintext);
    }
    if (message.algorithm !== "") {
      writer.uint32(26).string(message.algorithm);
    }
    if (message.keyName !== "") {
      writer.uint32(34).string(message.keyName);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(42).bytes(message.nonce);
    }
    if (message.associatedData.length !== 0) {
      writer.uint32(50).bytes(message.associatedData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtleEncryptRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtleEncryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.componentName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.plaintext = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.keyName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.associatedData = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtleEncryptRequest {
    return {
      componentName: isSet(object.componentName) ? globalThis.String(object.componentName) : "",
      plaintext: isSet(object.plaintext) ? bytesFromBase64(object.plaintext) : new Uint8Array(0),
      algorithm: isSet(object.algorithm) ? globalThis.String(object.algorithm) : "",
      keyName: isSet(object.keyName) ? globalThis.String(object.keyName) : "",
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
      associatedData: isSet(object.associatedData) ? bytesFromBase64(object.associatedData) : new Uint8Array(0),
    };
  },

  toJSON(message: SubtleEncryptRequest): unknown {
    const obj: any = {};
    if (message.componentName !== "") {
      obj.componentName = message.componentName;
    }
    if (message.plaintext.length !== 0) {
      obj.plaintext = base64FromBytes(message.plaintext);
    }
    if (message.algorithm !== "") {
      obj.algorithm = message.algorithm;
    }
    if (message.keyName !== "") {
      obj.keyName = message.keyName;
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.associatedData.length !== 0) {
      obj.associatedData = base64FromBytes(message.associatedData);
    }
    return obj;
  },

  create(base?: DeepPartial<SubtleEncryptRequest>): SubtleEncryptRequest {
    return SubtleEncryptRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubtleEncryptRequest>): SubtleEncryptRequest {
    const message = createBaseSubtleEncryptRequest();
    message.componentName = object.componentName ?? "";
    message.plaintext = object.plaintext ?? new Uint8Array(0);
    message.algorithm = object.algorithm ?? "";
    message.keyName = object.keyName ?? "";
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.associatedData = object.associatedData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubtleEncryptResponse(): SubtleEncryptResponse {
  return { ciphertext: new Uint8Array(0), tag: new Uint8Array(0) };
}

export const SubtleEncryptResponse = {
  encode(message: SubtleEncryptResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ciphertext.length !== 0) {
      writer.uint32(10).bytes(message.ciphertext);
    }
    if (message.tag.length !== 0) {
      writer.uint32(18).bytes(message.tag);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtleEncryptResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtleEncryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tag = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtleEncryptResponse {
    return {
      ciphertext: isSet(object.ciphertext) ? bytesFromBase64(object.ciphertext) : new Uint8Array(0),
      tag: isSet(object.tag) ? bytesFromBase64(object.tag) : new Uint8Array(0),
    };
  },

  toJSON(message: SubtleEncryptResponse): unknown {
    const obj: any = {};
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.tag.length !== 0) {
      obj.tag = base64FromBytes(message.tag);
    }
    return obj;
  },

  create(base?: DeepPartial<SubtleEncryptResponse>): SubtleEncryptResponse {
    return SubtleEncryptResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubtleEncryptResponse>): SubtleEncryptResponse {
    const message = createBaseSubtleEncryptResponse();
    message.ciphertext = object.ciphertext ?? new Uint8Array(0);
    message.tag = object.tag ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubtleDecryptRequest(): SubtleDecryptRequest {
  return {
    componentName: "",
    ciphertext: new Uint8Array(0),
    algorithm: "",
    keyName: "",
    nonce: new Uint8Array(0),
    tag: new Uint8Array(0),
    associatedData: new Uint8Array(0),
  };
}

export const SubtleDecryptRequest = {
  encode(message: SubtleDecryptRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.componentName !== "") {
      writer.uint32(10).string(message.componentName);
    }
    if (message.ciphertext.length !== 0) {
      writer.uint32(18).bytes(message.ciphertext);
    }
    if (message.algorithm !== "") {
      writer.uint32(26).string(message.algorithm);
    }
    if (message.keyName !== "") {
      writer.uint32(34).string(message.keyName);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(42).bytes(message.nonce);
    }
    if (message.tag.length !== 0) {
      writer.uint32(50).bytes(message.tag);
    }
    if (message.associatedData.length !== 0) {
      writer.uint32(58).bytes(message.associatedData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtleDecryptRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtleDecryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.componentName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.keyName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tag = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.associatedData = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtleDecryptRequest {
    return {
      componentName: isSet(object.componentName) ? globalThis.String(object.componentName) : "",
      ciphertext: isSet(object.ciphertext) ? bytesFromBase64(object.ciphertext) : new Uint8Array(0),
      algorithm: isSet(object.algorithm) ? globalThis.String(object.algorithm) : "",
      keyName: isSet(object.keyName) ? globalThis.String(object.keyName) : "",
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
      tag: isSet(object.tag) ? bytesFromBase64(object.tag) : new Uint8Array(0),
      associatedData: isSet(object.associatedData) ? bytesFromBase64(object.associatedData) : new Uint8Array(0),
    };
  },

  toJSON(message: SubtleDecryptRequest): unknown {
    const obj: any = {};
    if (message.componentName !== "") {
      obj.componentName = message.componentName;
    }
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.algorithm !== "") {
      obj.algorithm = message.algorithm;
    }
    if (message.keyName !== "") {
      obj.keyName = message.keyName;
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.tag.length !== 0) {
      obj.tag = base64FromBytes(message.tag);
    }
    if (message.associatedData.length !== 0) {
      obj.associatedData = base64FromBytes(message.associatedData);
    }
    return obj;
  },

  create(base?: DeepPartial<SubtleDecryptRequest>): SubtleDecryptRequest {
    return SubtleDecryptRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubtleDecryptRequest>): SubtleDecryptRequest {
    const message = createBaseSubtleDecryptRequest();
    message.componentName = object.componentName ?? "";
    message.ciphertext = object.ciphertext ?? new Uint8Array(0);
    message.algorithm = object.algorithm ?? "";
    message.keyName = object.keyName ?? "";
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.tag = object.tag ?? new Uint8Array(0);
    message.associatedData = object.associatedData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubtleDecryptResponse(): SubtleDecryptResponse {
  return { plaintext: new Uint8Array(0) };
}

export const SubtleDecryptResponse = {
  encode(message: SubtleDecryptResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.plaintext.length !== 0) {
      writer.uint32(10).bytes(message.plaintext);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtleDecryptResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtleDecryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.plaintext = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtleDecryptResponse {
    return { plaintext: isSet(object.plaintext) ? bytesFromBase64(object.plaintext) : new Uint8Array(0) };
  },

  toJSON(message: SubtleDecryptResponse): unknown {
    const obj: any = {};
    if (message.plaintext.length !== 0) {
      obj.plaintext = base64FromBytes(message.plaintext);
    }
    return obj;
  },

  create(base?: DeepPartial<SubtleDecryptResponse>): SubtleDecryptResponse {
    return SubtleDecryptResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubtleDecryptResponse>): SubtleDecryptResponse {
    const message = createBaseSubtleDecryptResponse();
    message.plaintext = object.plaintext ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubtleWrapKeyRequest(): SubtleWrapKeyRequest {
  return {
    componentName: "",
    plaintextKey: new Uint8Array(0),
    algorithm: "",
    keyName: "",
    nonce: new Uint8Array(0),
    associatedData: new Uint8Array(0),
  };
}

export const SubtleWrapKeyRequest = {
  encode(message: SubtleWrapKeyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.componentName !== "") {
      writer.uint32(10).string(message.componentName);
    }
    if (message.plaintextKey.length !== 0) {
      writer.uint32(18).bytes(message.plaintextKey);
    }
    if (message.algorithm !== "") {
      writer.uint32(26).string(message.algorithm);
    }
    if (message.keyName !== "") {
      writer.uint32(34).string(message.keyName);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(42).bytes(message.nonce);
    }
    if (message.associatedData.length !== 0) {
      writer.uint32(50).bytes(message.associatedData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtleWrapKeyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtleWrapKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.componentName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.plaintextKey = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.keyName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.associatedData = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtleWrapKeyRequest {
    return {
      componentName: isSet(object.componentName) ? globalThis.String(object.componentName) : "",
      plaintextKey: isSet(object.plaintextKey) ? bytesFromBase64(object.plaintextKey) : new Uint8Array(0),
      algorithm: isSet(object.algorithm) ? globalThis.String(object.algorithm) : "",
      keyName: isSet(object.keyName) ? globalThis.String(object.keyName) : "",
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
      associatedData: isSet(object.associatedData) ? bytesFromBase64(object.associatedData) : new Uint8Array(0),
    };
  },

  toJSON(message: SubtleWrapKeyRequest): unknown {
    const obj: any = {};
    if (message.componentName !== "") {
      obj.componentName = message.componentName;
    }
    if (message.plaintextKey.length !== 0) {
      obj.plaintextKey = base64FromBytes(message.plaintextKey);
    }
    if (message.algorithm !== "") {
      obj.algorithm = message.algorithm;
    }
    if (message.keyName !== "") {
      obj.keyName = message.keyName;
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.associatedData.length !== 0) {
      obj.associatedData = base64FromBytes(message.associatedData);
    }
    return obj;
  },

  create(base?: DeepPartial<SubtleWrapKeyRequest>): SubtleWrapKeyRequest {
    return SubtleWrapKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubtleWrapKeyRequest>): SubtleWrapKeyRequest {
    const message = createBaseSubtleWrapKeyRequest();
    message.componentName = object.componentName ?? "";
    message.plaintextKey = object.plaintextKey ?? new Uint8Array(0);
    message.algorithm = object.algorithm ?? "";
    message.keyName = object.keyName ?? "";
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.associatedData = object.associatedData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubtleWrapKeyResponse(): SubtleWrapKeyResponse {
  return { wrappedKey: new Uint8Array(0), tag: new Uint8Array(0) };
}

export const SubtleWrapKeyResponse = {
  encode(message: SubtleWrapKeyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.wrappedKey.length !== 0) {
      writer.uint32(10).bytes(message.wrappedKey);
    }
    if (message.tag.length !== 0) {
      writer.uint32(18).bytes(message.tag);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtleWrapKeyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtleWrapKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wrappedKey = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tag = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtleWrapKeyResponse {
    return {
      wrappedKey: isSet(object.wrappedKey) ? bytesFromBase64(object.wrappedKey) : new Uint8Array(0),
      tag: isSet(object.tag) ? bytesFromBase64(object.tag) : new Uint8Array(0),
    };
  },

  toJSON(message: SubtleWrapKeyResponse): unknown {
    const obj: any = {};
    if (message.wrappedKey.length !== 0) {
      obj.wrappedKey = base64FromBytes(message.wrappedKey);
    }
    if (message.tag.length !== 0) {
      obj.tag = base64FromBytes(message.tag);
    }
    return obj;
  },

  create(base?: DeepPartial<SubtleWrapKeyResponse>): SubtleWrapKeyResponse {
    return SubtleWrapKeyResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubtleWrapKeyResponse>): SubtleWrapKeyResponse {
    const message = createBaseSubtleWrapKeyResponse();
    message.wrappedKey = object.wrappedKey ?? new Uint8Array(0);
    message.tag = object.tag ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubtleUnwrapKeyRequest(): SubtleUnwrapKeyRequest {
  return {
    componentName: "",
    wrappedKey: new Uint8Array(0),
    algorithm: "",
    keyName: "",
    nonce: new Uint8Array(0),
    tag: new Uint8Array(0),
    associatedData: new Uint8Array(0),
  };
}

export const SubtleUnwrapKeyRequest = {
  encode(message: SubtleUnwrapKeyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.componentName !== "") {
      writer.uint32(10).string(message.componentName);
    }
    if (message.wrappedKey.length !== 0) {
      writer.uint32(18).bytes(message.wrappedKey);
    }
    if (message.algorithm !== "") {
      writer.uint32(26).string(message.algorithm);
    }
    if (message.keyName !== "") {
      writer.uint32(34).string(message.keyName);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(42).bytes(message.nonce);
    }
    if (message.tag.length !== 0) {
      writer.uint32(50).bytes(message.tag);
    }
    if (message.associatedData.length !== 0) {
      writer.uint32(58).bytes(message.associatedData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtleUnwrapKeyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtleUnwrapKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.componentName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.wrappedKey = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.keyName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tag = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.associatedData = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtleUnwrapKeyRequest {
    return {
      componentName: isSet(object.componentName) ? globalThis.String(object.componentName) : "",
      wrappedKey: isSet(object.wrappedKey) ? bytesFromBase64(object.wrappedKey) : new Uint8Array(0),
      algorithm: isSet(object.algorithm) ? globalThis.String(object.algorithm) : "",
      keyName: isSet(object.keyName) ? globalThis.String(object.keyName) : "",
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
      tag: isSet(object.tag) ? bytesFromBase64(object.tag) : new Uint8Array(0),
      associatedData: isSet(object.associatedData) ? bytesFromBase64(object.associatedData) : new Uint8Array(0),
    };
  },

  toJSON(message: SubtleUnwrapKeyRequest): unknown {
    const obj: any = {};
    if (message.componentName !== "") {
      obj.componentName = message.componentName;
    }
    if (message.wrappedKey.length !== 0) {
      obj.wrappedKey = base64FromBytes(message.wrappedKey);
    }
    if (message.algorithm !== "") {
      obj.algorithm = message.algorithm;
    }
    if (message.keyName !== "") {
      obj.keyName = message.keyName;
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.tag.length !== 0) {
      obj.tag = base64FromBytes(message.tag);
    }
    if (message.associatedData.length !== 0) {
      obj.associatedData = base64FromBytes(message.associatedData);
    }
    return obj;
  },

  create(base?: DeepPartial<SubtleUnwrapKeyRequest>): SubtleUnwrapKeyRequest {
    return SubtleUnwrapKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubtleUnwrapKeyRequest>): SubtleUnwrapKeyRequest {
    const message = createBaseSubtleUnwrapKeyRequest();
    message.componentName = object.componentName ?? "";
    message.wrappedKey = object.wrappedKey ?? new Uint8Array(0);
    message.algorithm = object.algorithm ?? "";
    message.keyName = object.keyName ?? "";
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.tag = object.tag ?? new Uint8Array(0);
    message.associatedData = object.associatedData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubtleUnwrapKeyResponse(): SubtleUnwrapKeyResponse {
  return { plaintextKey: new Uint8Array(0) };
}

export const SubtleUnwrapKeyResponse = {
  encode(message: SubtleUnwrapKeyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.plaintextKey.length !== 0) {
      writer.uint32(10).bytes(message.plaintextKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtleUnwrapKeyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtleUnwrapKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.plaintextKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtleUnwrapKeyResponse {
    return { plaintextKey: isSet(object.plaintextKey) ? bytesFromBase64(object.plaintextKey) : new Uint8Array(0) };
  },

  toJSON(message: SubtleUnwrapKeyResponse): unknown {
    const obj: any = {};
    if (message.plaintextKey.length !== 0) {
      obj.plaintextKey = base64FromBytes(message.plaintextKey);
    }
    return obj;
  },

  create(base?: DeepPartial<SubtleUnwrapKeyResponse>): SubtleUnwrapKeyResponse {
    return SubtleUnwrapKeyResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubtleUnwrapKeyResponse>): SubtleUnwrapKeyResponse {
    const message = createBaseSubtleUnwrapKeyResponse();
    message.plaintextKey = object.plaintextKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubtleSignRequest(): SubtleSignRequest {
  return { componentName: "", digest: new Uint8Array(0), algorithm: "", keyName: "" };
}

export const SubtleSignRequest = {
  encode(message: SubtleSignRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.componentName !== "") {
      writer.uint32(10).string(message.componentName);
    }
    if (message.digest.length !== 0) {
      writer.uint32(18).bytes(message.digest);
    }
    if (message.algorithm !== "") {
      writer.uint32(26).string(message.algorithm);
    }
    if (message.keyName !== "") {
      writer.uint32(34).string(message.keyName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtleSignRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtleSignRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.componentName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.digest = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.keyName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtleSignRequest {
    return {
      componentName: isSet(object.componentName) ? globalThis.String(object.componentName) : "",
      digest: isSet(object.digest) ? bytesFromBase64(object.digest) : new Uint8Array(0),
      algorithm: isSet(object.algorithm) ? globalThis.String(object.algorithm) : "",
      keyName: isSet(object.keyName) ? globalThis.String(object.keyName) : "",
    };
  },

  toJSON(message: SubtleSignRequest): unknown {
    const obj: any = {};
    if (message.componentName !== "") {
      obj.componentName = message.componentName;
    }
    if (message.digest.length !== 0) {
      obj.digest = base64FromBytes(message.digest);
    }
    if (message.algorithm !== "") {
      obj.algorithm = message.algorithm;
    }
    if (message.keyName !== "") {
      obj.keyName = message.keyName;
    }
    return obj;
  },

  create(base?: DeepPartial<SubtleSignRequest>): SubtleSignRequest {
    return SubtleSignRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubtleSignRequest>): SubtleSignRequest {
    const message = createBaseSubtleSignRequest();
    message.componentName = object.componentName ?? "";
    message.digest = object.digest ?? new Uint8Array(0);
    message.algorithm = object.algorithm ?? "";
    message.keyName = object.keyName ?? "";
    return message;
  },
};

function createBaseSubtleSignResponse(): SubtleSignResponse {
  return { signature: new Uint8Array(0) };
}

export const SubtleSignResponse = {
  encode(message: SubtleSignResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signature.length !== 0) {
      writer.uint32(10).bytes(message.signature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtleSignResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtleSignResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signature = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtleSignResponse {
    return { signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0) };
  },

  toJSON(message: SubtleSignResponse): unknown {
    const obj: any = {};
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create(base?: DeepPartial<SubtleSignResponse>): SubtleSignResponse {
    return SubtleSignResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubtleSignResponse>): SubtleSignResponse {
    const message = createBaseSubtleSignResponse();
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubtleVerifyRequest(): SubtleVerifyRequest {
  return { componentName: "", digest: new Uint8Array(0), algorithm: "", keyName: "", signature: new Uint8Array(0) };
}

export const SubtleVerifyRequest = {
  encode(message: SubtleVerifyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.componentName !== "") {
      writer.uint32(10).string(message.componentName);
    }
    if (message.digest.length !== 0) {
      writer.uint32(18).bytes(message.digest);
    }
    if (message.algorithm !== "") {
      writer.uint32(26).string(message.algorithm);
    }
    if (message.keyName !== "") {
      writer.uint32(34).string(message.keyName);
    }
    if (message.signature.length !== 0) {
      writer.uint32(42).bytes(message.signature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtleVerifyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtleVerifyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.componentName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.digest = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.keyName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.signature = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtleVerifyRequest {
    return {
      componentName: isSet(object.componentName) ? globalThis.String(object.componentName) : "",
      digest: isSet(object.digest) ? bytesFromBase64(object.digest) : new Uint8Array(0),
      algorithm: isSet(object.algorithm) ? globalThis.String(object.algorithm) : "",
      keyName: isSet(object.keyName) ? globalThis.String(object.keyName) : "",
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
    };
  },

  toJSON(message: SubtleVerifyRequest): unknown {
    const obj: any = {};
    if (message.componentName !== "") {
      obj.componentName = message.componentName;
    }
    if (message.digest.length !== 0) {
      obj.digest = base64FromBytes(message.digest);
    }
    if (message.algorithm !== "") {
      obj.algorithm = message.algorithm;
    }
    if (message.keyName !== "") {
      obj.keyName = message.keyName;
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create(base?: DeepPartial<SubtleVerifyRequest>): SubtleVerifyRequest {
    return SubtleVerifyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubtleVerifyRequest>): SubtleVerifyRequest {
    const message = createBaseSubtleVerifyRequest();
    message.componentName = object.componentName ?? "";
    message.digest = object.digest ?? new Uint8Array(0);
    message.algorithm = object.algorithm ?? "";
    message.keyName = object.keyName ?? "";
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubtleVerifyResponse(): SubtleVerifyResponse {
  return { valid: false };
}

export const SubtleVerifyResponse = {
  encode(message: SubtleVerifyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubtleVerifyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubtleVerifyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubtleVerifyResponse {
    return { valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false };
  },

  toJSON(message: SubtleVerifyResponse): unknown {
    const obj: any = {};
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    return obj;
  },

  create(base?: DeepPartial<SubtleVerifyResponse>): SubtleVerifyResponse {
    return SubtleVerifyResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubtleVerifyResponse>): SubtleVerifyResponse {
    const message = createBaseSubtleVerifyResponse();
    message.valid = object.valid ?? false;
    return message;
  },
};

function createBaseEncryptRequest(): EncryptRequest {
  return { options: undefined, payload: undefined };
}

export const EncryptRequest = {
  encode(message: EncryptRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.options !== undefined) {
      EncryptRequestOptions.encode(message.options, writer.uint32(10).fork()).ldelim();
    }
    if (message.payload !== undefined) {
      StreamPayload.encode(message.payload, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EncryptRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.options = EncryptRequestOptions.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = StreamPayload.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptRequest {
    return {
      options: isSet(object.options) ? EncryptRequestOptions.fromJSON(object.options) : undefined,
      payload: isSet(object.payload) ? StreamPayload.fromJSON(object.payload) : undefined,
    };
  },

  toJSON(message: EncryptRequest): unknown {
    const obj: any = {};
    if (message.options !== undefined) {
      obj.options = EncryptRequestOptions.toJSON(message.options);
    }
    if (message.payload !== undefined) {
      obj.payload = StreamPayload.toJSON(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<EncryptRequest>): EncryptRequest {
    return EncryptRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EncryptRequest>): EncryptRequest {
    const message = createBaseEncryptRequest();
    message.options = (object.options !== undefined && object.options !== null)
      ? EncryptRequestOptions.fromPartial(object.options)
      : undefined;
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? StreamPayload.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseEncryptRequestOptions(): EncryptRequestOptions {
  return {
    componentName: "",
    keyName: "",
    keyWrapAlgorithm: "",
    dataEncryptionCipher: "",
    omitDecryptionKeyName: false,
    decryptionKeyName: "",
  };
}

export const EncryptRequestOptions = {
  encode(message: EncryptRequestOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.componentName !== "") {
      writer.uint32(10).string(message.componentName);
    }
    if (message.keyName !== "") {
      writer.uint32(18).string(message.keyName);
    }
    if (message.keyWrapAlgorithm !== "") {
      writer.uint32(26).string(message.keyWrapAlgorithm);
    }
    if (message.dataEncryptionCipher !== "") {
      writer.uint32(82).string(message.dataEncryptionCipher);
    }
    if (message.omitDecryptionKeyName !== false) {
      writer.uint32(88).bool(message.omitDecryptionKeyName);
    }
    if (message.decryptionKeyName !== "") {
      writer.uint32(98).string(message.decryptionKeyName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EncryptRequestOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptRequestOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.componentName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keyName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keyWrapAlgorithm = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.dataEncryptionCipher = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.omitDecryptionKeyName = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.decryptionKeyName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptRequestOptions {
    return {
      componentName: isSet(object.componentName) ? globalThis.String(object.componentName) : "",
      keyName: isSet(object.keyName) ? globalThis.String(object.keyName) : "",
      keyWrapAlgorithm: isSet(object.keyWrapAlgorithm) ? globalThis.String(object.keyWrapAlgorithm) : "",
      dataEncryptionCipher: isSet(object.dataEncryptionCipher) ? globalThis.String(object.dataEncryptionCipher) : "",
      omitDecryptionKeyName: isSet(object.omitDecryptionKeyName)
        ? globalThis.Boolean(object.omitDecryptionKeyName)
        : false,
      decryptionKeyName: isSet(object.decryptionKeyName) ? globalThis.String(object.decryptionKeyName) : "",
    };
  },

  toJSON(message: EncryptRequestOptions): unknown {
    const obj: any = {};
    if (message.componentName !== "") {
      obj.componentName = message.componentName;
    }
    if (message.keyName !== "") {
      obj.keyName = message.keyName;
    }
    if (message.keyWrapAlgorithm !== "") {
      obj.keyWrapAlgorithm = message.keyWrapAlgorithm;
    }
    if (message.dataEncryptionCipher !== "") {
      obj.dataEncryptionCipher = message.dataEncryptionCipher;
    }
    if (message.omitDecryptionKeyName !== false) {
      obj.omitDecryptionKeyName = message.omitDecryptionKeyName;
    }
    if (message.decryptionKeyName !== "") {
      obj.decryptionKeyName = message.decryptionKeyName;
    }
    return obj;
  },

  create(base?: DeepPartial<EncryptRequestOptions>): EncryptRequestOptions {
    return EncryptRequestOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EncryptRequestOptions>): EncryptRequestOptions {
    const message = createBaseEncryptRequestOptions();
    message.componentName = object.componentName ?? "";
    message.keyName = object.keyName ?? "";
    message.keyWrapAlgorithm = object.keyWrapAlgorithm ?? "";
    message.dataEncryptionCipher = object.dataEncryptionCipher ?? "";
    message.omitDecryptionKeyName = object.omitDecryptionKeyName ?? false;
    message.decryptionKeyName = object.decryptionKeyName ?? "";
    return message;
  },
};

function createBaseEncryptResponse(): EncryptResponse {
  return { payload: undefined };
}

export const EncryptResponse = {
  encode(message: EncryptResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.payload !== undefined) {
      StreamPayload.encode(message.payload, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EncryptResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payload = StreamPayload.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptResponse {
    return { payload: isSet(object.payload) ? StreamPayload.fromJSON(object.payload) : undefined };
  },

  toJSON(message: EncryptResponse): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = StreamPayload.toJSON(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<EncryptResponse>): EncryptResponse {
    return EncryptResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EncryptResponse>): EncryptResponse {
    const message = createBaseEncryptResponse();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? StreamPayload.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseDecryptRequest(): DecryptRequest {
  return { options: undefined, payload: undefined };
}

export const DecryptRequest = {
  encode(message: DecryptRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.options !== undefined) {
      DecryptRequestOptions.encode(message.options, writer.uint32(10).fork()).ldelim();
    }
    if (message.payload !== undefined) {
      StreamPayload.encode(message.payload, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DecryptRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.options = DecryptRequestOptions.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = StreamPayload.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptRequest {
    return {
      options: isSet(object.options) ? DecryptRequestOptions.fromJSON(object.options) : undefined,
      payload: isSet(object.payload) ? StreamPayload.fromJSON(object.payload) : undefined,
    };
  },

  toJSON(message: DecryptRequest): unknown {
    const obj: any = {};
    if (message.options !== undefined) {
      obj.options = DecryptRequestOptions.toJSON(message.options);
    }
    if (message.payload !== undefined) {
      obj.payload = StreamPayload.toJSON(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<DecryptRequest>): DecryptRequest {
    return DecryptRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DecryptRequest>): DecryptRequest {
    const message = createBaseDecryptRequest();
    message.options = (object.options !== undefined && object.options !== null)
      ? DecryptRequestOptions.fromPartial(object.options)
      : undefined;
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? StreamPayload.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseDecryptRequestOptions(): DecryptRequestOptions {
  return { componentName: "", keyName: "" };
}

export const DecryptRequestOptions = {
  encode(message: DecryptRequestOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.componentName !== "") {
      writer.uint32(10).string(message.componentName);
    }
    if (message.keyName !== "") {
      writer.uint32(98).string(message.keyName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DecryptRequestOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptRequestOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.componentName = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.keyName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptRequestOptions {
    return {
      componentName: isSet(object.componentName) ? globalThis.String(object.componentName) : "",
      keyName: isSet(object.keyName) ? globalThis.String(object.keyName) : "",
    };
  },

  toJSON(message: DecryptRequestOptions): unknown {
    const obj: any = {};
    if (message.componentName !== "") {
      obj.componentName = message.componentName;
    }
    if (message.keyName !== "") {
      obj.keyName = message.keyName;
    }
    return obj;
  },

  create(base?: DeepPartial<DecryptRequestOptions>): DecryptRequestOptions {
    return DecryptRequestOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DecryptRequestOptions>): DecryptRequestOptions {
    const message = createBaseDecryptRequestOptions();
    message.componentName = object.componentName ?? "";
    message.keyName = object.keyName ?? "";
    return message;
  },
};

function createBaseDecryptResponse(): DecryptResponse {
  return { payload: undefined };
}

export const DecryptResponse = {
  encode(message: DecryptResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.payload !== undefined) {
      StreamPayload.encode(message.payload, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DecryptResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecryptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payload = StreamPayload.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecryptResponse {
    return { payload: isSet(object.payload) ? StreamPayload.fromJSON(object.payload) : undefined };
  },

  toJSON(message: DecryptResponse): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = StreamPayload.toJSON(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<DecryptResponse>): DecryptResponse {
    return DecryptResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DecryptResponse>): DecryptResponse {
    const message = createBaseDecryptResponse();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? StreamPayload.fromPartial(object.payload)
      : undefined;
    return message;
  },
};

function createBaseGetWorkflowRequest(): GetWorkflowRequest {
  return { instanceId: "", workflowComponent: "" };
}

export const GetWorkflowRequest = {
  encode(message: GetWorkflowRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.workflowComponent !== "") {
      writer.uint32(18).string(message.workflowComponent);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWorkflowRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workflowComponent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkflowRequest {
    return {
      instanceId: isSet(object.instanceID) ? globalThis.String(object.instanceID) : "",
      workflowComponent: isSet(object.workflowComponent) ? globalThis.String(object.workflowComponent) : "",
    };
  },

  toJSON(message: GetWorkflowRequest): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceID = message.instanceId;
    }
    if (message.workflowComponent !== "") {
      obj.workflowComponent = message.workflowComponent;
    }
    return obj;
  },

  create(base?: DeepPartial<GetWorkflowRequest>): GetWorkflowRequest {
    return GetWorkflowRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWorkflowRequest>): GetWorkflowRequest {
    const message = createBaseGetWorkflowRequest();
    message.instanceId = object.instanceId ?? "";
    message.workflowComponent = object.workflowComponent ?? "";
    return message;
  },
};

function createBaseGetWorkflowResponse(): GetWorkflowResponse {
  return {
    instanceId: "",
    workflowName: "",
    createdAt: undefined,
    lastUpdatedAt: undefined,
    runtimeStatus: "",
    properties: {},
  };
}

export const GetWorkflowResponse = {
  encode(message: GetWorkflowResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.workflowName !== "") {
      writer.uint32(18).string(message.workflowName);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(26).fork()).ldelim();
    }
    if (message.lastUpdatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.lastUpdatedAt), writer.uint32(34).fork()).ldelim();
    }
    if (message.runtimeStatus !== "") {
      writer.uint32(42).string(message.runtimeStatus);
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      GetWorkflowResponse_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWorkflowResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkflowResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workflowName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lastUpdatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.runtimeStatus = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = GetWorkflowResponse_PropertiesEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.properties[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkflowResponse {
    return {
      instanceId: isSet(object.instanceID) ? globalThis.String(object.instanceID) : "",
      workflowName: isSet(object.workflowName) ? globalThis.String(object.workflowName) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      lastUpdatedAt: isSet(object.lastUpdatedAt) ? fromJsonTimestamp(object.lastUpdatedAt) : undefined,
      runtimeStatus: isSet(object.runtimeStatus) ? globalThis.String(object.runtimeStatus) : "",
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetWorkflowResponse): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceID = message.instanceId;
    }
    if (message.workflowName !== "") {
      obj.workflowName = message.workflowName;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.lastUpdatedAt !== undefined) {
      obj.lastUpdatedAt = message.lastUpdatedAt.toISOString();
    }
    if (message.runtimeStatus !== "") {
      obj.runtimeStatus = message.runtimeStatus;
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetWorkflowResponse>): GetWorkflowResponse {
    return GetWorkflowResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWorkflowResponse>): GetWorkflowResponse {
    const message = createBaseGetWorkflowResponse();
    message.instanceId = object.instanceId ?? "";
    message.workflowName = object.workflowName ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.lastUpdatedAt = object.lastUpdatedAt ?? undefined;
    message.runtimeStatus = object.runtimeStatus ?? "";
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGetWorkflowResponse_PropertiesEntry(): GetWorkflowResponse_PropertiesEntry {
  return { key: "", value: "" };
}

export const GetWorkflowResponse_PropertiesEntry = {
  encode(message: GetWorkflowResponse_PropertiesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWorkflowResponse_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkflowResponse_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkflowResponse_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GetWorkflowResponse_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GetWorkflowResponse_PropertiesEntry>): GetWorkflowResponse_PropertiesEntry {
    return GetWorkflowResponse_PropertiesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWorkflowResponse_PropertiesEntry>): GetWorkflowResponse_PropertiesEntry {
    const message = createBaseGetWorkflowResponse_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStartWorkflowRequest(): StartWorkflowRequest {
  return { instanceId: "", workflowComponent: "", workflowName: "", options: {}, input: new Uint8Array(0) };
}

export const StartWorkflowRequest = {
  encode(message: StartWorkflowRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.workflowComponent !== "") {
      writer.uint32(18).string(message.workflowComponent);
    }
    if (message.workflowName !== "") {
      writer.uint32(26).string(message.workflowName);
    }
    Object.entries(message.options).forEach(([key, value]) => {
      StartWorkflowRequest_OptionsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    if (message.input.length !== 0) {
      writer.uint32(42).bytes(message.input);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartWorkflowRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workflowComponent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.workflowName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = StartWorkflowRequest_OptionsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.options[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.input = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartWorkflowRequest {
    return {
      instanceId: isSet(object.instanceID) ? globalThis.String(object.instanceID) : "",
      workflowComponent: isSet(object.workflowComponent) ? globalThis.String(object.workflowComponent) : "",
      workflowName: isSet(object.workflowName) ? globalThis.String(object.workflowName) : "",
      options: isObject(object.options)
        ? Object.entries(object.options).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      input: isSet(object.input) ? bytesFromBase64(object.input) : new Uint8Array(0),
    };
  },

  toJSON(message: StartWorkflowRequest): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceID = message.instanceId;
    }
    if (message.workflowComponent !== "") {
      obj.workflowComponent = message.workflowComponent;
    }
    if (message.workflowName !== "") {
      obj.workflowName = message.workflowName;
    }
    if (message.options) {
      const entries = Object.entries(message.options);
      if (entries.length > 0) {
        obj.options = {};
        entries.forEach(([k, v]) => {
          obj.options[k] = v;
        });
      }
    }
    if (message.input.length !== 0) {
      obj.input = base64FromBytes(message.input);
    }
    return obj;
  },

  create(base?: DeepPartial<StartWorkflowRequest>): StartWorkflowRequest {
    return StartWorkflowRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartWorkflowRequest>): StartWorkflowRequest {
    const message = createBaseStartWorkflowRequest();
    message.instanceId = object.instanceId ?? "";
    message.workflowComponent = object.workflowComponent ?? "";
    message.workflowName = object.workflowName ?? "";
    message.options = Object.entries(object.options ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.input = object.input ?? new Uint8Array(0);
    return message;
  },
};

function createBaseStartWorkflowRequest_OptionsEntry(): StartWorkflowRequest_OptionsEntry {
  return { key: "", value: "" };
}

export const StartWorkflowRequest_OptionsEntry = {
  encode(message: StartWorkflowRequest_OptionsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartWorkflowRequest_OptionsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartWorkflowRequest_OptionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartWorkflowRequest_OptionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: StartWorkflowRequest_OptionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<StartWorkflowRequest_OptionsEntry>): StartWorkflowRequest_OptionsEntry {
    return StartWorkflowRequest_OptionsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartWorkflowRequest_OptionsEntry>): StartWorkflowRequest_OptionsEntry {
    const message = createBaseStartWorkflowRequest_OptionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStartWorkflowResponse(): StartWorkflowResponse {
  return { instanceId: "" };
}

export const StartWorkflowResponse = {
  encode(message: StartWorkflowResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartWorkflowResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartWorkflowResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartWorkflowResponse {
    return { instanceId: isSet(object.instanceID) ? globalThis.String(object.instanceID) : "" };
  },

  toJSON(message: StartWorkflowResponse): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceID = message.instanceId;
    }
    return obj;
  },

  create(base?: DeepPartial<StartWorkflowResponse>): StartWorkflowResponse {
    return StartWorkflowResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartWorkflowResponse>): StartWorkflowResponse {
    const message = createBaseStartWorkflowResponse();
    message.instanceId = object.instanceId ?? "";
    return message;
  },
};

function createBaseTerminateWorkflowRequest(): TerminateWorkflowRequest {
  return { instanceId: "", workflowComponent: "" };
}

export const TerminateWorkflowRequest = {
  encode(message: TerminateWorkflowRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.workflowComponent !== "") {
      writer.uint32(18).string(message.workflowComponent);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TerminateWorkflowRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTerminateWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workflowComponent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TerminateWorkflowRequest {
    return {
      instanceId: isSet(object.instanceID) ? globalThis.String(object.instanceID) : "",
      workflowComponent: isSet(object.workflowComponent) ? globalThis.String(object.workflowComponent) : "",
    };
  },

  toJSON(message: TerminateWorkflowRequest): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceID = message.instanceId;
    }
    if (message.workflowComponent !== "") {
      obj.workflowComponent = message.workflowComponent;
    }
    return obj;
  },

  create(base?: DeepPartial<TerminateWorkflowRequest>): TerminateWorkflowRequest {
    return TerminateWorkflowRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TerminateWorkflowRequest>): TerminateWorkflowRequest {
    const message = createBaseTerminateWorkflowRequest();
    message.instanceId = object.instanceId ?? "";
    message.workflowComponent = object.workflowComponent ?? "";
    return message;
  },
};

function createBasePauseWorkflowRequest(): PauseWorkflowRequest {
  return { instanceId: "", workflowComponent: "" };
}

export const PauseWorkflowRequest = {
  encode(message: PauseWorkflowRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.workflowComponent !== "") {
      writer.uint32(18).string(message.workflowComponent);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PauseWorkflowRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePauseWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workflowComponent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PauseWorkflowRequest {
    return {
      instanceId: isSet(object.instanceID) ? globalThis.String(object.instanceID) : "",
      workflowComponent: isSet(object.workflowComponent) ? globalThis.String(object.workflowComponent) : "",
    };
  },

  toJSON(message: PauseWorkflowRequest): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceID = message.instanceId;
    }
    if (message.workflowComponent !== "") {
      obj.workflowComponent = message.workflowComponent;
    }
    return obj;
  },

  create(base?: DeepPartial<PauseWorkflowRequest>): PauseWorkflowRequest {
    return PauseWorkflowRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PauseWorkflowRequest>): PauseWorkflowRequest {
    const message = createBasePauseWorkflowRequest();
    message.instanceId = object.instanceId ?? "";
    message.workflowComponent = object.workflowComponent ?? "";
    return message;
  },
};

function createBaseResumeWorkflowRequest(): ResumeWorkflowRequest {
  return { instanceId: "", workflowComponent: "" };
}

export const ResumeWorkflowRequest = {
  encode(message: ResumeWorkflowRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.workflowComponent !== "") {
      writer.uint32(18).string(message.workflowComponent);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ResumeWorkflowRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResumeWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workflowComponent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResumeWorkflowRequest {
    return {
      instanceId: isSet(object.instanceID) ? globalThis.String(object.instanceID) : "",
      workflowComponent: isSet(object.workflowComponent) ? globalThis.String(object.workflowComponent) : "",
    };
  },

  toJSON(message: ResumeWorkflowRequest): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceID = message.instanceId;
    }
    if (message.workflowComponent !== "") {
      obj.workflowComponent = message.workflowComponent;
    }
    return obj;
  },

  create(base?: DeepPartial<ResumeWorkflowRequest>): ResumeWorkflowRequest {
    return ResumeWorkflowRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResumeWorkflowRequest>): ResumeWorkflowRequest {
    const message = createBaseResumeWorkflowRequest();
    message.instanceId = object.instanceId ?? "";
    message.workflowComponent = object.workflowComponent ?? "";
    return message;
  },
};

function createBaseRaiseEventWorkflowRequest(): RaiseEventWorkflowRequest {
  return { instanceId: "", workflowComponent: "", eventName: "", eventData: new Uint8Array(0) };
}

export const RaiseEventWorkflowRequest = {
  encode(message: RaiseEventWorkflowRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.workflowComponent !== "") {
      writer.uint32(18).string(message.workflowComponent);
    }
    if (message.eventName !== "") {
      writer.uint32(26).string(message.eventName);
    }
    if (message.eventData.length !== 0) {
      writer.uint32(34).bytes(message.eventData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RaiseEventWorkflowRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRaiseEventWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workflowComponent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.eventData = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RaiseEventWorkflowRequest {
    return {
      instanceId: isSet(object.instanceID) ? globalThis.String(object.instanceID) : "",
      workflowComponent: isSet(object.workflowComponent) ? globalThis.String(object.workflowComponent) : "",
      eventName: isSet(object.eventName) ? globalThis.String(object.eventName) : "",
      eventData: isSet(object.eventData) ? bytesFromBase64(object.eventData) : new Uint8Array(0),
    };
  },

  toJSON(message: RaiseEventWorkflowRequest): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceID = message.instanceId;
    }
    if (message.workflowComponent !== "") {
      obj.workflowComponent = message.workflowComponent;
    }
    if (message.eventName !== "") {
      obj.eventName = message.eventName;
    }
    if (message.eventData.length !== 0) {
      obj.eventData = base64FromBytes(message.eventData);
    }
    return obj;
  },

  create(base?: DeepPartial<RaiseEventWorkflowRequest>): RaiseEventWorkflowRequest {
    return RaiseEventWorkflowRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RaiseEventWorkflowRequest>): RaiseEventWorkflowRequest {
    const message = createBaseRaiseEventWorkflowRequest();
    message.instanceId = object.instanceId ?? "";
    message.workflowComponent = object.workflowComponent ?? "";
    message.eventName = object.eventName ?? "";
    message.eventData = object.eventData ?? new Uint8Array(0);
    return message;
  },
};

function createBasePurgeWorkflowRequest(): PurgeWorkflowRequest {
  return { instanceId: "", workflowComponent: "" };
}

export const PurgeWorkflowRequest = {
  encode(message: PurgeWorkflowRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.instanceId !== "") {
      writer.uint32(10).string(message.instanceId);
    }
    if (message.workflowComponent !== "") {
      writer.uint32(18).string(message.workflowComponent);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PurgeWorkflowRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurgeWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workflowComponent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurgeWorkflowRequest {
    return {
      instanceId: isSet(object.instanceID) ? globalThis.String(object.instanceID) : "",
      workflowComponent: isSet(object.workflowComponent) ? globalThis.String(object.workflowComponent) : "",
    };
  },

  toJSON(message: PurgeWorkflowRequest): unknown {
    const obj: any = {};
    if (message.instanceId !== "") {
      obj.instanceID = message.instanceId;
    }
    if (message.workflowComponent !== "") {
      obj.workflowComponent = message.workflowComponent;
    }
    return obj;
  },

  create(base?: DeepPartial<PurgeWorkflowRequest>): PurgeWorkflowRequest {
    return PurgeWorkflowRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurgeWorkflowRequest>): PurgeWorkflowRequest {
    const message = createBasePurgeWorkflowRequest();
    message.instanceId = object.instanceId ?? "";
    message.workflowComponent = object.workflowComponent ?? "";
    return message;
  },
};

function createBaseShutdownRequest(): ShutdownRequest {
  return {};
}

export const ShutdownRequest = {
  encode(_: ShutdownRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ShutdownRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShutdownRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ShutdownRequest {
    return {};
  },

  toJSON(_: ShutdownRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ShutdownRequest>): ShutdownRequest {
    return ShutdownRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ShutdownRequest>): ShutdownRequest {
    const message = createBaseShutdownRequest();
    return message;
  },
};

/** Dapr service provides APIs to user application to access Dapr building blocks. */
export type DaprDefinition = typeof DaprDefinition;
export const DaprDefinition = {
  name: "Dapr",
  fullName: "dapr.proto.runtime.v1.Dapr",
  methods: {
    /**
     * Invokes a method on a remote Dapr app.
     * Deprecated: Use proxy mode service invocation instead.
     */
    invokeService: {
      name: "InvokeService",
      requestType: InvokeServiceRequest,
      requestStream: false,
      responseType: InvokeResponse,
      responseStream: false,
      options: {},
    },
    /** Gets the state for a specific key. */
    getState: {
      name: "GetState",
      requestType: GetStateRequest,
      requestStream: false,
      responseType: GetStateResponse,
      responseStream: false,
      options: {},
    },
    /** Gets a bulk of state items for a list of keys */
    getBulkState: {
      name: "GetBulkState",
      requestType: GetBulkStateRequest,
      requestStream: false,
      responseType: GetBulkStateResponse,
      responseStream: false,
      options: {},
    },
    /** Saves the state for a specific key. */
    saveState: {
      name: "SaveState",
      requestType: SaveStateRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Queries the state. */
    queryStateAlpha1: {
      name: "QueryStateAlpha1",
      requestType: QueryStateRequest,
      requestStream: false,
      responseType: QueryStateResponse,
      responseStream: false,
      options: {},
    },
    /** Deletes the state for a specific key. */
    deleteState: {
      name: "DeleteState",
      requestType: DeleteStateRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Deletes a bulk of state items for a list of keys */
    deleteBulkState: {
      name: "DeleteBulkState",
      requestType: DeleteBulkStateRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Executes transactions for a specified store */
    executeStateTransaction: {
      name: "ExecuteStateTransaction",
      requestType: ExecuteStateTransactionRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Publishes events to the specific topic. */
    publishEvent: {
      name: "PublishEvent",
      requestType: PublishEventRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Bulk Publishes multiple events to the specified topic. */
    bulkPublishEventAlpha1: {
      name: "BulkPublishEventAlpha1",
      requestType: BulkPublishRequest,
      requestStream: false,
      responseType: BulkPublishResponse,
      responseStream: false,
      options: {},
    },
    /**
     * SubscribeTopicEventsAlpha1 subscribes to a PubSub topic and receives topic
     * events from it.
     */
    subscribeTopicEventsAlpha1: {
      name: "SubscribeTopicEventsAlpha1",
      requestType: SubscribeTopicEventsRequestAlpha1,
      requestStream: true,
      responseType: TopicEventRequest,
      responseStream: true,
      options: {},
    },
    /** Invokes binding data to specific output bindings */
    invokeBinding: {
      name: "InvokeBinding",
      requestType: InvokeBindingRequest,
      requestStream: false,
      responseType: InvokeBindingResponse,
      responseStream: false,
      options: {},
    },
    /** Gets secrets from secret stores. */
    getSecret: {
      name: "GetSecret",
      requestType: GetSecretRequest,
      requestStream: false,
      responseType: GetSecretResponse,
      responseStream: false,
      options: {},
    },
    /** Gets a bulk of secrets */
    getBulkSecret: {
      name: "GetBulkSecret",
      requestType: GetBulkSecretRequest,
      requestStream: false,
      responseType: GetBulkSecretResponse,
      responseStream: false,
      options: {},
    },
    /** Register an actor timer. */
    registerActorTimer: {
      name: "RegisterActorTimer",
      requestType: RegisterActorTimerRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Unregister an actor timer. */
    unregisterActorTimer: {
      name: "UnregisterActorTimer",
      requestType: UnregisterActorTimerRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Register an actor reminder. */
    registerActorReminder: {
      name: "RegisterActorReminder",
      requestType: RegisterActorReminderRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Unregister an actor reminder. */
    unregisterActorReminder: {
      name: "UnregisterActorReminder",
      requestType: UnregisterActorReminderRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Gets the state for a specific actor. */
    getActorState: {
      name: "GetActorState",
      requestType: GetActorStateRequest,
      requestStream: false,
      responseType: GetActorStateResponse,
      responseStream: false,
      options: {},
    },
    /** Executes state transactions for a specified actor */
    executeActorStateTransaction: {
      name: "ExecuteActorStateTransaction",
      requestType: ExecuteActorStateTransactionRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** InvokeActor calls a method on an actor. */
    invokeActor: {
      name: "InvokeActor",
      requestType: InvokeActorRequest,
      requestStream: false,
      responseType: InvokeActorResponse,
      responseStream: false,
      options: {},
    },
    /** GetConfiguration gets configuration from configuration store. */
    getConfigurationAlpha1: {
      name: "GetConfigurationAlpha1",
      requestType: GetConfigurationRequest,
      requestStream: false,
      responseType: GetConfigurationResponse,
      responseStream: false,
      options: {},
    },
    /** GetConfiguration gets configuration from configuration store. */
    getConfiguration: {
      name: "GetConfiguration",
      requestType: GetConfigurationRequest,
      requestStream: false,
      responseType: GetConfigurationResponse,
      responseStream: false,
      options: {},
    },
    /** SubscribeConfiguration gets configuration from configuration store and subscribe the updates event by grpc stream */
    subscribeConfigurationAlpha1: {
      name: "SubscribeConfigurationAlpha1",
      requestType: SubscribeConfigurationRequest,
      requestStream: false,
      responseType: SubscribeConfigurationResponse,
      responseStream: true,
      options: {},
    },
    /** SubscribeConfiguration gets configuration from configuration store and subscribe the updates event by grpc stream */
    subscribeConfiguration: {
      name: "SubscribeConfiguration",
      requestType: SubscribeConfigurationRequest,
      requestStream: false,
      responseType: SubscribeConfigurationResponse,
      responseStream: true,
      options: {},
    },
    /** UnSubscribeConfiguration unsubscribe the subscription of configuration */
    unsubscribeConfigurationAlpha1: {
      name: "UnsubscribeConfigurationAlpha1",
      requestType: UnsubscribeConfigurationRequest,
      requestStream: false,
      responseType: UnsubscribeConfigurationResponse,
      responseStream: false,
      options: {},
    },
    /** UnSubscribeConfiguration unsubscribe the subscription of configuration */
    unsubscribeConfiguration: {
      name: "UnsubscribeConfiguration",
      requestType: UnsubscribeConfigurationRequest,
      requestStream: false,
      responseType: UnsubscribeConfigurationResponse,
      responseStream: false,
      options: {},
    },
    /** TryLockAlpha1 tries to get a lock with an expiry. */
    tryLockAlpha1: {
      name: "TryLockAlpha1",
      requestType: TryLockRequest,
      requestStream: false,
      responseType: TryLockResponse,
      responseStream: false,
      options: {},
    },
    /** UnlockAlpha1 unlocks a lock. */
    unlockAlpha1: {
      name: "UnlockAlpha1",
      requestType: UnlockRequest,
      requestStream: false,
      responseType: UnlockResponse,
      responseStream: false,
      options: {},
    },
    /** EncryptAlpha1 encrypts a message using the Dapr encryption scheme and a key stored in the vault. */
    encryptAlpha1: {
      name: "EncryptAlpha1",
      requestType: EncryptRequest,
      requestStream: true,
      responseType: EncryptResponse,
      responseStream: true,
      options: {},
    },
    /** DecryptAlpha1 decrypts a message using the Dapr encryption scheme and a key stored in the vault. */
    decryptAlpha1: {
      name: "DecryptAlpha1",
      requestType: DecryptRequest,
      requestStream: true,
      responseType: DecryptResponse,
      responseStream: true,
      options: {},
    },
    /** Gets metadata of the sidecar */
    getMetadata: {
      name: "GetMetadata",
      requestType: GetMetadataRequest,
      requestStream: false,
      responseType: GetMetadataResponse,
      responseStream: false,
      options: {},
    },
    /** Sets value in extended metadata of the sidecar */
    setMetadata: {
      name: "SetMetadata",
      requestType: SetMetadataRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** SubtleGetKeyAlpha1 returns the public part of an asymmetric key stored in the vault. */
    subtleGetKeyAlpha1: {
      name: "SubtleGetKeyAlpha1",
      requestType: SubtleGetKeyRequest,
      requestStream: false,
      responseType: SubtleGetKeyResponse,
      responseStream: false,
      options: {},
    },
    /** SubtleEncryptAlpha1 encrypts a small message using a key stored in the vault. */
    subtleEncryptAlpha1: {
      name: "SubtleEncryptAlpha1",
      requestType: SubtleEncryptRequest,
      requestStream: false,
      responseType: SubtleEncryptResponse,
      responseStream: false,
      options: {},
    },
    /** SubtleDecryptAlpha1 decrypts a small message using a key stored in the vault. */
    subtleDecryptAlpha1: {
      name: "SubtleDecryptAlpha1",
      requestType: SubtleDecryptRequest,
      requestStream: false,
      responseType: SubtleDecryptResponse,
      responseStream: false,
      options: {},
    },
    /** SubtleWrapKeyAlpha1 wraps a key using a key stored in the vault. */
    subtleWrapKeyAlpha1: {
      name: "SubtleWrapKeyAlpha1",
      requestType: SubtleWrapKeyRequest,
      requestStream: false,
      responseType: SubtleWrapKeyResponse,
      responseStream: false,
      options: {},
    },
    /** SubtleUnwrapKeyAlpha1 unwraps a key using a key stored in the vault. */
    subtleUnwrapKeyAlpha1: {
      name: "SubtleUnwrapKeyAlpha1",
      requestType: SubtleUnwrapKeyRequest,
      requestStream: false,
      responseType: SubtleUnwrapKeyResponse,
      responseStream: false,
      options: {},
    },
    /** SubtleSignAlpha1 signs a message using a key stored in the vault. */
    subtleSignAlpha1: {
      name: "SubtleSignAlpha1",
      requestType: SubtleSignRequest,
      requestStream: false,
      responseType: SubtleSignResponse,
      responseStream: false,
      options: {},
    },
    /** SubtleVerifyAlpha1 verifies the signature of a message using a key stored in the vault. */
    subtleVerifyAlpha1: {
      name: "SubtleVerifyAlpha1",
      requestType: SubtleVerifyRequest,
      requestStream: false,
      responseType: SubtleVerifyResponse,
      responseStream: false,
      options: {},
    },
    /** Starts a new instance of a workflow */
    startWorkflowAlpha1: {
      name: "StartWorkflowAlpha1",
      requestType: StartWorkflowRequest,
      requestStream: false,
      responseType: StartWorkflowResponse,
      responseStream: false,
      options: {},
    },
    /** Gets details about a started workflow instance */
    getWorkflowAlpha1: {
      name: "GetWorkflowAlpha1",
      requestType: GetWorkflowRequest,
      requestStream: false,
      responseType: GetWorkflowResponse,
      responseStream: false,
      options: {},
    },
    /** Purge Workflow */
    purgeWorkflowAlpha1: {
      name: "PurgeWorkflowAlpha1",
      requestType: PurgeWorkflowRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Terminates a running workflow instance */
    terminateWorkflowAlpha1: {
      name: "TerminateWorkflowAlpha1",
      requestType: TerminateWorkflowRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Pauses a running workflow instance */
    pauseWorkflowAlpha1: {
      name: "PauseWorkflowAlpha1",
      requestType: PauseWorkflowRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Resumes a paused workflow instance */
    resumeWorkflowAlpha1: {
      name: "ResumeWorkflowAlpha1",
      requestType: ResumeWorkflowRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Raise an event to a running workflow instance */
    raiseEventWorkflowAlpha1: {
      name: "RaiseEventWorkflowAlpha1",
      requestType: RaiseEventWorkflowRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Starts a new instance of a workflow */
    startWorkflowBeta1: {
      name: "StartWorkflowBeta1",
      requestType: StartWorkflowRequest,
      requestStream: false,
      responseType: StartWorkflowResponse,
      responseStream: false,
      options: {},
    },
    /** Gets details about a started workflow instance */
    getWorkflowBeta1: {
      name: "GetWorkflowBeta1",
      requestType: GetWorkflowRequest,
      requestStream: false,
      responseType: GetWorkflowResponse,
      responseStream: false,
      options: {},
    },
    /** Purge Workflow */
    purgeWorkflowBeta1: {
      name: "PurgeWorkflowBeta1",
      requestType: PurgeWorkflowRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Terminates a running workflow instance */
    terminateWorkflowBeta1: {
      name: "TerminateWorkflowBeta1",
      requestType: TerminateWorkflowRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Pauses a running workflow instance */
    pauseWorkflowBeta1: {
      name: "PauseWorkflowBeta1",
      requestType: PauseWorkflowRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Resumes a paused workflow instance */
    resumeWorkflowBeta1: {
      name: "ResumeWorkflowBeta1",
      requestType: ResumeWorkflowRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Raise an event to a running workflow instance */
    raiseEventWorkflowBeta1: {
      name: "RaiseEventWorkflowBeta1",
      requestType: RaiseEventWorkflowRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Shutdown the sidecar */
    shutdown: {
      name: "Shutdown",
      requestType: ShutdownRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface DaprServiceImplementation<CallContextExt = {}> {
  /**
   * Invokes a method on a remote Dapr app.
   * Deprecated: Use proxy mode service invocation instead.
   */
  invokeService(
    request: InvokeServiceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<InvokeResponse>>;
  /** Gets the state for a specific key. */
  getState(request: GetStateRequest, context: CallContext & CallContextExt): Promise<DeepPartial<GetStateResponse>>;
  /** Gets a bulk of state items for a list of keys */
  getBulkState(
    request: GetBulkStateRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetBulkStateResponse>>;
  /** Saves the state for a specific key. */
  saveState(request: SaveStateRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Queries the state. */
  queryStateAlpha1(
    request: QueryStateRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryStateResponse>>;
  /** Deletes the state for a specific key. */
  deleteState(request: DeleteStateRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Deletes a bulk of state items for a list of keys */
  deleteBulkState(request: DeleteBulkStateRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Executes transactions for a specified store */
  executeStateTransaction(
    request: ExecuteStateTransactionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Publishes events to the specific topic. */
  publishEvent(request: PublishEventRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Bulk Publishes multiple events to the specified topic. */
  bulkPublishEventAlpha1(
    request: BulkPublishRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BulkPublishResponse>>;
  /**
   * SubscribeTopicEventsAlpha1 subscribes to a PubSub topic and receives topic
   * events from it.
   */
  subscribeTopicEventsAlpha1(
    request: AsyncIterable<SubscribeTopicEventsRequestAlpha1>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<TopicEventRequest>>;
  /** Invokes binding data to specific output bindings */
  invokeBinding(
    request: InvokeBindingRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<InvokeBindingResponse>>;
  /** Gets secrets from secret stores. */
  getSecret(request: GetSecretRequest, context: CallContext & CallContextExt): Promise<DeepPartial<GetSecretResponse>>;
  /** Gets a bulk of secrets */
  getBulkSecret(
    request: GetBulkSecretRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetBulkSecretResponse>>;
  /** Register an actor timer. */
  registerActorTimer(
    request: RegisterActorTimerRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Unregister an actor timer. */
  unregisterActorTimer(
    request: UnregisterActorTimerRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Register an actor reminder. */
  registerActorReminder(
    request: RegisterActorReminderRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Unregister an actor reminder. */
  unregisterActorReminder(
    request: UnregisterActorReminderRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Gets the state for a specific actor. */
  getActorState(
    request: GetActorStateRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetActorStateResponse>>;
  /** Executes state transactions for a specified actor */
  executeActorStateTransaction(
    request: ExecuteActorStateTransactionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** InvokeActor calls a method on an actor. */
  invokeActor(
    request: InvokeActorRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<InvokeActorResponse>>;
  /** GetConfiguration gets configuration from configuration store. */
  getConfigurationAlpha1(
    request: GetConfigurationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetConfigurationResponse>>;
  /** GetConfiguration gets configuration from configuration store. */
  getConfiguration(
    request: GetConfigurationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetConfigurationResponse>>;
  /** SubscribeConfiguration gets configuration from configuration store and subscribe the updates event by grpc stream */
  subscribeConfigurationAlpha1(
    request: SubscribeConfigurationRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<SubscribeConfigurationResponse>>;
  /** SubscribeConfiguration gets configuration from configuration store and subscribe the updates event by grpc stream */
  subscribeConfiguration(
    request: SubscribeConfigurationRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<SubscribeConfigurationResponse>>;
  /** UnSubscribeConfiguration unsubscribe the subscription of configuration */
  unsubscribeConfigurationAlpha1(
    request: UnsubscribeConfigurationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UnsubscribeConfigurationResponse>>;
  /** UnSubscribeConfiguration unsubscribe the subscription of configuration */
  unsubscribeConfiguration(
    request: UnsubscribeConfigurationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UnsubscribeConfigurationResponse>>;
  /** TryLockAlpha1 tries to get a lock with an expiry. */
  tryLockAlpha1(request: TryLockRequest, context: CallContext & CallContextExt): Promise<DeepPartial<TryLockResponse>>;
  /** UnlockAlpha1 unlocks a lock. */
  unlockAlpha1(request: UnlockRequest, context: CallContext & CallContextExt): Promise<DeepPartial<UnlockResponse>>;
  /** EncryptAlpha1 encrypts a message using the Dapr encryption scheme and a key stored in the vault. */
  encryptAlpha1(
    request: AsyncIterable<EncryptRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<EncryptResponse>>;
  /** DecryptAlpha1 decrypts a message using the Dapr encryption scheme and a key stored in the vault. */
  decryptAlpha1(
    request: AsyncIterable<DecryptRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<DecryptResponse>>;
  /** Gets metadata of the sidecar */
  getMetadata(
    request: GetMetadataRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetMetadataResponse>>;
  /** Sets value in extended metadata of the sidecar */
  setMetadata(request: SetMetadataRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** SubtleGetKeyAlpha1 returns the public part of an asymmetric key stored in the vault. */
  subtleGetKeyAlpha1(
    request: SubtleGetKeyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SubtleGetKeyResponse>>;
  /** SubtleEncryptAlpha1 encrypts a small message using a key stored in the vault. */
  subtleEncryptAlpha1(
    request: SubtleEncryptRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SubtleEncryptResponse>>;
  /** SubtleDecryptAlpha1 decrypts a small message using a key stored in the vault. */
  subtleDecryptAlpha1(
    request: SubtleDecryptRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SubtleDecryptResponse>>;
  /** SubtleWrapKeyAlpha1 wraps a key using a key stored in the vault. */
  subtleWrapKeyAlpha1(
    request: SubtleWrapKeyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SubtleWrapKeyResponse>>;
  /** SubtleUnwrapKeyAlpha1 unwraps a key using a key stored in the vault. */
  subtleUnwrapKeyAlpha1(
    request: SubtleUnwrapKeyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SubtleUnwrapKeyResponse>>;
  /** SubtleSignAlpha1 signs a message using a key stored in the vault. */
  subtleSignAlpha1(
    request: SubtleSignRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SubtleSignResponse>>;
  /** SubtleVerifyAlpha1 verifies the signature of a message using a key stored in the vault. */
  subtleVerifyAlpha1(
    request: SubtleVerifyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SubtleVerifyResponse>>;
  /** Starts a new instance of a workflow */
  startWorkflowAlpha1(
    request: StartWorkflowRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartWorkflowResponse>>;
  /** Gets details about a started workflow instance */
  getWorkflowAlpha1(
    request: GetWorkflowRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetWorkflowResponse>>;
  /** Purge Workflow */
  purgeWorkflowAlpha1(
    request: PurgeWorkflowRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Terminates a running workflow instance */
  terminateWorkflowAlpha1(
    request: TerminateWorkflowRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Pauses a running workflow instance */
  pauseWorkflowAlpha1(
    request: PauseWorkflowRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Resumes a paused workflow instance */
  resumeWorkflowAlpha1(
    request: ResumeWorkflowRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Raise an event to a running workflow instance */
  raiseEventWorkflowAlpha1(
    request: RaiseEventWorkflowRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Starts a new instance of a workflow */
  startWorkflowBeta1(
    request: StartWorkflowRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StartWorkflowResponse>>;
  /** Gets details about a started workflow instance */
  getWorkflowBeta1(
    request: GetWorkflowRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetWorkflowResponse>>;
  /** Purge Workflow */
  purgeWorkflowBeta1(request: PurgeWorkflowRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Terminates a running workflow instance */
  terminateWorkflowBeta1(
    request: TerminateWorkflowRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Pauses a running workflow instance */
  pauseWorkflowBeta1(request: PauseWorkflowRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Resumes a paused workflow instance */
  resumeWorkflowBeta1(
    request: ResumeWorkflowRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Raise an event to a running workflow instance */
  raiseEventWorkflowBeta1(
    request: RaiseEventWorkflowRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Shutdown the sidecar */
  shutdown(request: ShutdownRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
}

export interface DaprClient<CallOptionsExt = {}> {
  /**
   * Invokes a method on a remote Dapr app.
   * Deprecated: Use proxy mode service invocation instead.
   */
  invokeService(
    request: DeepPartial<InvokeServiceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<InvokeResponse>;
  /** Gets the state for a specific key. */
  getState(request: DeepPartial<GetStateRequest>, options?: CallOptions & CallOptionsExt): Promise<GetStateResponse>;
  /** Gets a bulk of state items for a list of keys */
  getBulkState(
    request: DeepPartial<GetBulkStateRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetBulkStateResponse>;
  /** Saves the state for a specific key. */
  saveState(request: DeepPartial<SaveStateRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Queries the state. */
  queryStateAlpha1(
    request: DeepPartial<QueryStateRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryStateResponse>;
  /** Deletes the state for a specific key. */
  deleteState(request: DeepPartial<DeleteStateRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Deletes a bulk of state items for a list of keys */
  deleteBulkState(request: DeepPartial<DeleteBulkStateRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Executes transactions for a specified store */
  executeStateTransaction(
    request: DeepPartial<ExecuteStateTransactionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Publishes events to the specific topic. */
  publishEvent(request: DeepPartial<PublishEventRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Bulk Publishes multiple events to the specified topic. */
  bulkPublishEventAlpha1(
    request: DeepPartial<BulkPublishRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BulkPublishResponse>;
  /**
   * SubscribeTopicEventsAlpha1 subscribes to a PubSub topic and receives topic
   * events from it.
   */
  subscribeTopicEventsAlpha1(
    request: AsyncIterable<DeepPartial<SubscribeTopicEventsRequestAlpha1>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<TopicEventRequest>;
  /** Invokes binding data to specific output bindings */
  invokeBinding(
    request: DeepPartial<InvokeBindingRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<InvokeBindingResponse>;
  /** Gets secrets from secret stores. */
  getSecret(request: DeepPartial<GetSecretRequest>, options?: CallOptions & CallOptionsExt): Promise<GetSecretResponse>;
  /** Gets a bulk of secrets */
  getBulkSecret(
    request: DeepPartial<GetBulkSecretRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetBulkSecretResponse>;
  /** Register an actor timer. */
  registerActorTimer(
    request: DeepPartial<RegisterActorTimerRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Unregister an actor timer. */
  unregisterActorTimer(
    request: DeepPartial<UnregisterActorTimerRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Register an actor reminder. */
  registerActorReminder(
    request: DeepPartial<RegisterActorReminderRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Unregister an actor reminder. */
  unregisterActorReminder(
    request: DeepPartial<UnregisterActorReminderRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Gets the state for a specific actor. */
  getActorState(
    request: DeepPartial<GetActorStateRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetActorStateResponse>;
  /** Executes state transactions for a specified actor */
  executeActorStateTransaction(
    request: DeepPartial<ExecuteActorStateTransactionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** InvokeActor calls a method on an actor. */
  invokeActor(
    request: DeepPartial<InvokeActorRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<InvokeActorResponse>;
  /** GetConfiguration gets configuration from configuration store. */
  getConfigurationAlpha1(
    request: DeepPartial<GetConfigurationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetConfigurationResponse>;
  /** GetConfiguration gets configuration from configuration store. */
  getConfiguration(
    request: DeepPartial<GetConfigurationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetConfigurationResponse>;
  /** SubscribeConfiguration gets configuration from configuration store and subscribe the updates event by grpc stream */
  subscribeConfigurationAlpha1(
    request: DeepPartial<SubscribeConfigurationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<SubscribeConfigurationResponse>;
  /** SubscribeConfiguration gets configuration from configuration store and subscribe the updates event by grpc stream */
  subscribeConfiguration(
    request: DeepPartial<SubscribeConfigurationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<SubscribeConfigurationResponse>;
  /** UnSubscribeConfiguration unsubscribe the subscription of configuration */
  unsubscribeConfigurationAlpha1(
    request: DeepPartial<UnsubscribeConfigurationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UnsubscribeConfigurationResponse>;
  /** UnSubscribeConfiguration unsubscribe the subscription of configuration */
  unsubscribeConfiguration(
    request: DeepPartial<UnsubscribeConfigurationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UnsubscribeConfigurationResponse>;
  /** TryLockAlpha1 tries to get a lock with an expiry. */
  tryLockAlpha1(request: DeepPartial<TryLockRequest>, options?: CallOptions & CallOptionsExt): Promise<TryLockResponse>;
  /** UnlockAlpha1 unlocks a lock. */
  unlockAlpha1(request: DeepPartial<UnlockRequest>, options?: CallOptions & CallOptionsExt): Promise<UnlockResponse>;
  /** EncryptAlpha1 encrypts a message using the Dapr encryption scheme and a key stored in the vault. */
  encryptAlpha1(
    request: AsyncIterable<DeepPartial<EncryptRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<EncryptResponse>;
  /** DecryptAlpha1 decrypts a message using the Dapr encryption scheme and a key stored in the vault. */
  decryptAlpha1(
    request: AsyncIterable<DeepPartial<DecryptRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<DecryptResponse>;
  /** Gets metadata of the sidecar */
  getMetadata(
    request: DeepPartial<GetMetadataRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetMetadataResponse>;
  /** Sets value in extended metadata of the sidecar */
  setMetadata(request: DeepPartial<SetMetadataRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** SubtleGetKeyAlpha1 returns the public part of an asymmetric key stored in the vault. */
  subtleGetKeyAlpha1(
    request: DeepPartial<SubtleGetKeyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SubtleGetKeyResponse>;
  /** SubtleEncryptAlpha1 encrypts a small message using a key stored in the vault. */
  subtleEncryptAlpha1(
    request: DeepPartial<SubtleEncryptRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SubtleEncryptResponse>;
  /** SubtleDecryptAlpha1 decrypts a small message using a key stored in the vault. */
  subtleDecryptAlpha1(
    request: DeepPartial<SubtleDecryptRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SubtleDecryptResponse>;
  /** SubtleWrapKeyAlpha1 wraps a key using a key stored in the vault. */
  subtleWrapKeyAlpha1(
    request: DeepPartial<SubtleWrapKeyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SubtleWrapKeyResponse>;
  /** SubtleUnwrapKeyAlpha1 unwraps a key using a key stored in the vault. */
  subtleUnwrapKeyAlpha1(
    request: DeepPartial<SubtleUnwrapKeyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SubtleUnwrapKeyResponse>;
  /** SubtleSignAlpha1 signs a message using a key stored in the vault. */
  subtleSignAlpha1(
    request: DeepPartial<SubtleSignRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SubtleSignResponse>;
  /** SubtleVerifyAlpha1 verifies the signature of a message using a key stored in the vault. */
  subtleVerifyAlpha1(
    request: DeepPartial<SubtleVerifyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SubtleVerifyResponse>;
  /** Starts a new instance of a workflow */
  startWorkflowAlpha1(
    request: DeepPartial<StartWorkflowRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartWorkflowResponse>;
  /** Gets details about a started workflow instance */
  getWorkflowAlpha1(
    request: DeepPartial<GetWorkflowRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetWorkflowResponse>;
  /** Purge Workflow */
  purgeWorkflowAlpha1(
    request: DeepPartial<PurgeWorkflowRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Terminates a running workflow instance */
  terminateWorkflowAlpha1(
    request: DeepPartial<TerminateWorkflowRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Pauses a running workflow instance */
  pauseWorkflowAlpha1(
    request: DeepPartial<PauseWorkflowRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Resumes a paused workflow instance */
  resumeWorkflowAlpha1(
    request: DeepPartial<ResumeWorkflowRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Raise an event to a running workflow instance */
  raiseEventWorkflowAlpha1(
    request: DeepPartial<RaiseEventWorkflowRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Starts a new instance of a workflow */
  startWorkflowBeta1(
    request: DeepPartial<StartWorkflowRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StartWorkflowResponse>;
  /** Gets details about a started workflow instance */
  getWorkflowBeta1(
    request: DeepPartial<GetWorkflowRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetWorkflowResponse>;
  /** Purge Workflow */
  purgeWorkflowBeta1(
    request: DeepPartial<PurgeWorkflowRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Terminates a running workflow instance */
  terminateWorkflowBeta1(
    request: DeepPartial<TerminateWorkflowRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Pauses a running workflow instance */
  pauseWorkflowBeta1(
    request: DeepPartial<PauseWorkflowRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Resumes a paused workflow instance */
  resumeWorkflowBeta1(
    request: DeepPartial<ResumeWorkflowRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Raise an event to a running workflow instance */
  raiseEventWorkflowBeta1(
    request: DeepPartial<RaiseEventWorkflowRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Shutdown the sidecar */
  shutdown(request: DeepPartial<ShutdownRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };
