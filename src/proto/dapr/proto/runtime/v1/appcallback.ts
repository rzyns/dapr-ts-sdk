// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.180.0
//   protoc               v3.19.1
// source: dapr/proto/runtime/v1/appcallback.proto

/* eslint-disable */
import { type CallContext, type CallOptions } from "nice-grpc-common";
import _m0 from "protobufjs/minimal.js";
import { Empty } from "../../../../google/protobuf/empty.js";
import { Struct } from "../../../../google/protobuf/struct.js";
import { InvokeRequest, InvokeResponse, StateItem } from "../../common/v1/common.js";

export const protobufPackage = "dapr.proto.runtime.v1";

/**
 * TopicEventRequest message is compatible with CloudEvent spec v1.0
 * https://github.com/cloudevents/spec/blob/v1.0/spec.md
 */
export interface TopicEventRequest {
  /**
   * id identifies the event. Producers MUST ensure that source + id
   * is unique for each distinct event. If a duplicate event is re-sent
   * (e.g. due to a network error) it MAY have the same id.
   */
  id: string;
  /**
   * source identifies the context in which an event happened.
   * Often this will include information such as the type of the
   * event source, the organization publishing the event or the process
   * that produced the event. The exact syntax and semantics behind
   * the data encoded in the URI is defined by the event producer.
   */
  source: string;
  /** The type of event related to the originating occurrence. */
  type: string;
  /** The version of the CloudEvents specification. */
  specVersion: string;
  /** The content type of data value. */
  dataContentType: string;
  /** The content of the event. */
  data: Uint8Array;
  /** The pubsub topic which publisher sent to. */
  topic: string;
  /** The name of the pubsub the publisher sent to. */
  pubsubName: string;
  /**
   * The matching path from TopicSubscription/routes (if specified) for this event.
   * This value is used by OnTopicEvent to "switch" inside the handler.
   */
  path: string;
  /** The map of additional custom properties to be sent to the app. These are considered to be cloud event extensions. */
  extensions: { [key: string]: any } | undefined;
}

/** TopicEventResponse is response from app on published message */
export interface TopicEventResponse {
  /** The list of output bindings. */
  status: TopicEventResponse_TopicEventResponseStatus;
}

/** TopicEventResponseStatus allows apps to have finer control over handling of the message. */
export enum TopicEventResponse_TopicEventResponseStatus {
  /** SUCCESS - SUCCESS is the default behavior: message is acknowledged and not retried or logged. */
  SUCCESS = 0,
  /** RETRY - RETRY status signals Dapr to retry the message as part of an expected scenario (no warning is logged). */
  RETRY = 1,
  /** DROP - DROP status signals Dapr to drop the message as part of an unexpected scenario (warning is logged). */
  DROP = 2,
  UNRECOGNIZED = -1,
}

export function topicEventResponse_TopicEventResponseStatusFromJSON(
  object: any,
): TopicEventResponse_TopicEventResponseStatus {
  switch (object) {
    case 0:
    case "SUCCESS":
      return TopicEventResponse_TopicEventResponseStatus.SUCCESS;
    case 1:
    case "RETRY":
      return TopicEventResponse_TopicEventResponseStatus.RETRY;
    case 2:
    case "DROP":
      return TopicEventResponse_TopicEventResponseStatus.DROP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TopicEventResponse_TopicEventResponseStatus.UNRECOGNIZED;
  }
}

export function topicEventResponse_TopicEventResponseStatusToJSON(
  object: TopicEventResponse_TopicEventResponseStatus,
): string {
  switch (object) {
    case TopicEventResponse_TopicEventResponseStatus.SUCCESS:
      return "SUCCESS";
    case TopicEventResponse_TopicEventResponseStatus.RETRY:
      return "RETRY";
    case TopicEventResponse_TopicEventResponseStatus.DROP:
      return "DROP";
    case TopicEventResponse_TopicEventResponseStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** TopicEventCERequest message is compatible with CloudEvent spec v1.0 */
export interface TopicEventCERequest {
  /** The unique identifier of this cloud event. */
  id: string;
  /** source identifies the context in which an event happened. */
  source: string;
  /** The type of event related to the originating occurrence. */
  type: string;
  /** The version of the CloudEvents specification. */
  specVersion: string;
  /** The content type of data value. */
  dataContentType: string;
  /** The content of the event. */
  data: Uint8Array;
  /** Custom attributes which includes cloud event extensions. */
  extensions: { [key: string]: any } | undefined;
}

/** TopicEventBulkRequestEntry represents a single message inside a bulk request */
export interface TopicEventBulkRequestEntry {
  /** Unique identifier for the message. */
  entryId: string;
  bytes?: Uint8Array | undefined;
  cloudEvent?:
    | TopicEventCERequest
    | undefined;
  /** content type of the event contained. */
  contentType: string;
  /** The metadata associated with the event. */
  metadata: { [key: string]: string };
}

export interface TopicEventBulkRequestEntry_MetadataEntry {
  key: string;
  value: string;
}

/** TopicEventBulkRequest represents request for bulk message */
export interface TopicEventBulkRequest {
  /** Unique identifier for the bulk request. */
  id: string;
  /** The list of items inside this bulk request. */
  entries: TopicEventBulkRequestEntry[];
  /** The metadata associated with the this bulk request. */
  metadata: { [key: string]: string };
  /** The pubsub topic which publisher sent to. */
  topic: string;
  /** The name of the pubsub the publisher sent to. */
  pubsubName: string;
  /** The type of event related to the originating occurrence. */
  type: string;
  /**
   * The matching path from TopicSubscription/routes (if specified) for this event.
   * This value is used by OnTopicEvent to "switch" inside the handler.
   */
  path: string;
}

export interface TopicEventBulkRequest_MetadataEntry {
  key: string;
  value: string;
}

/**
 * TopicEventBulkResponseEntry Represents single response, as part of TopicEventBulkResponse, to be
 * sent by subscibed App for the corresponding single message during bulk subscribe
 */
export interface TopicEventBulkResponseEntry {
  /** Unique identifier associated the message. */
  entryId: string;
  /** The status of the response. */
  status: TopicEventResponse_TopicEventResponseStatus;
}

/** AppBulkResponse is response from app on published message */
export interface TopicEventBulkResponse {
  /** The list of all responses for the bulk request. */
  statuses: TopicEventBulkResponseEntry[];
}

/** BindingEventRequest represents input bindings event. */
export interface BindingEventRequest {
  /** Required. The name of the input binding component. */
  name: string;
  /** Required. The payload that the input bindings sent */
  data: Uint8Array;
  /** The metadata set by the input binging components. */
  metadata: { [key: string]: string };
}

export interface BindingEventRequest_MetadataEntry {
  key: string;
  value: string;
}

/**
 * BindingEventResponse includes operations to save state or
 * send data to output bindings optionally.
 */
export interface BindingEventResponse {
  /** The name of state store where states are saved. */
  storeName: string;
  /** The state key values which will be stored in store_name. */
  states: StateItem[];
  /** The list of output bindings. */
  to: string[];
  /** The content which will be sent to "to" output bindings. */
  data: Uint8Array;
  /**
   * The concurrency of output bindings to send data to
   * "to" output bindings list. The default is SEQUENTIAL.
   */
  concurrency: BindingEventResponse_BindingEventConcurrency;
}

/** BindingEventConcurrency is the kind of concurrency */
export enum BindingEventResponse_BindingEventConcurrency {
  /** SEQUENTIAL - SEQUENTIAL sends data to output bindings specified in "to" sequentially. */
  SEQUENTIAL = 0,
  /** PARALLEL - PARALLEL sends data to output bindings specified in "to" in parallel. */
  PARALLEL = 1,
  UNRECOGNIZED = -1,
}

export function bindingEventResponse_BindingEventConcurrencyFromJSON(
  object: any,
): BindingEventResponse_BindingEventConcurrency {
  switch (object) {
    case 0:
    case "SEQUENTIAL":
      return BindingEventResponse_BindingEventConcurrency.SEQUENTIAL;
    case 1:
    case "PARALLEL":
      return BindingEventResponse_BindingEventConcurrency.PARALLEL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BindingEventResponse_BindingEventConcurrency.UNRECOGNIZED;
  }
}

export function bindingEventResponse_BindingEventConcurrencyToJSON(
  object: BindingEventResponse_BindingEventConcurrency,
): string {
  switch (object) {
    case BindingEventResponse_BindingEventConcurrency.SEQUENTIAL:
      return "SEQUENTIAL";
    case BindingEventResponse_BindingEventConcurrency.PARALLEL:
      return "PARALLEL";
    case BindingEventResponse_BindingEventConcurrency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ListTopicSubscriptionsResponse is the message including the list of the subscribing topics. */
export interface ListTopicSubscriptionsResponse {
  /** The list of topics. */
  subscriptions: TopicSubscription[];
}

/** TopicSubscription represents topic and metadata. */
export interface TopicSubscription {
  /** Required. The name of the pubsub containing the topic below to subscribe to. */
  pubsubName: string;
  /** Required. The name of topic which will be subscribed */
  topic: string;
  /** The optional properties used for this topic's subscription e.g. session id */
  metadata: { [key: string]: string };
  /**
   * The optional routing rules to match against. In the gRPC interface, OnTopicEvent
   * is still invoked but the matching path is sent in the TopicEventRequest.
   */
  routes:
    | TopicRoutes
    | undefined;
  /** The optional dead letter queue for this topic to send events to. */
  deadLetterTopic: string;
  /** The optional bulk subscribe settings for this topic. */
  bulkSubscribe: BulkSubscribeConfig | undefined;
}

export interface TopicSubscription_MetadataEntry {
  key: string;
  value: string;
}

export interface TopicRoutes {
  /** The list of rules for this topic. */
  rules: TopicRule[];
  /** The default path for this topic. */
  default: string;
}

export interface TopicRule {
  /**
   * The optional CEL expression used to match the event.
   * If the match is not specified, then the route is considered
   * the default.
   */
  match: string;
  /**
   * The path used to identify matches for this subscription.
   * This value is passed in TopicEventRequest and used by OnTopicEvent to "switch"
   * inside the handler.
   */
  path: string;
}

/** BulkSubscribeConfig is the message to pass settings for bulk subscribe */
export interface BulkSubscribeConfig {
  /** Required. Flag to enable/disable bulk subscribe */
  enabled: boolean;
  /** Optional. Max number of messages to be sent in a single bulk request */
  maxMessagesCount: number;
  /** Optional. Max duration to wait for messages to be sent in a single bulk request */
  maxAwaitDurationMs: number;
}

/** ListInputBindingsResponse is the message including the list of input bindings. */
export interface ListInputBindingsResponse {
  /** The list of input bindings. */
  bindings: string[];
}

/**
 * HealthCheckResponse is the message with the response to the health check.
 * This message is currently empty as used as placeholder.
 */
export interface HealthCheckResponse {
}

function createBaseTopicEventRequest(): TopicEventRequest {
  return {
    id: "",
    source: "",
    type: "",
    specVersion: "",
    dataContentType: "",
    data: new Uint8Array(0),
    topic: "",
    pubsubName: "",
    path: "",
    extensions: undefined,
  };
}

export const TopicEventRequest = {
  encode(message: TopicEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.specVersion !== "") {
      writer.uint32(34).string(message.specVersion);
    }
    if (message.dataContentType !== "") {
      writer.uint32(42).string(message.dataContentType);
    }
    if (message.data.length !== 0) {
      writer.uint32(58).bytes(message.data);
    }
    if (message.topic !== "") {
      writer.uint32(50).string(message.topic);
    }
    if (message.pubsubName !== "") {
      writer.uint32(66).string(message.pubsubName);
    }
    if (message.path !== "") {
      writer.uint32(74).string(message.path);
    }
    if (message.extensions !== undefined) {
      Struct.encode(Struct.wrap(message.extensions), writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.specVersion = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dataContentType = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.pubsubName = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.path = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.extensions = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicEventRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      specVersion: isSet(object.specVersion) ? globalThis.String(object.specVersion) : "",
      dataContentType: isSet(object.dataContentType) ? globalThis.String(object.dataContentType) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      pubsubName: isSet(object.pubsubName) ? globalThis.String(object.pubsubName) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      extensions: isObject(object.extensions) ? object.extensions : undefined,
    };
  },

  toJSON(message: TopicEventRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.specVersion !== "") {
      obj.specVersion = message.specVersion;
    }
    if (message.dataContentType !== "") {
      obj.dataContentType = message.dataContentType;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.pubsubName !== "") {
      obj.pubsubName = message.pubsubName;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.extensions !== undefined) {
      obj.extensions = message.extensions;
    }
    return obj;
  },

  create(base?: DeepPartial<TopicEventRequest>): TopicEventRequest {
    return TopicEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicEventRequest>): TopicEventRequest {
    const message = createBaseTopicEventRequest();
    message.id = object.id ?? "";
    message.source = object.source ?? "";
    message.type = object.type ?? "";
    message.specVersion = object.specVersion ?? "";
    message.dataContentType = object.dataContentType ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.topic = object.topic ?? "";
    message.pubsubName = object.pubsubName ?? "";
    message.path = object.path ?? "";
    message.extensions = object.extensions ?? undefined;
    return message;
  },
};

function createBaseTopicEventResponse(): TopicEventResponse {
  return { status: 0 };
}

export const TopicEventResponse = {
  encode(message: TopicEventResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicEventResponse {
    return { status: isSet(object.status) ? topicEventResponse_TopicEventResponseStatusFromJSON(object.status) : 0 };
  },

  toJSON(message: TopicEventResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = topicEventResponse_TopicEventResponseStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicEventResponse>): TopicEventResponse {
    return TopicEventResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicEventResponse>): TopicEventResponse {
    const message = createBaseTopicEventResponse();
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseTopicEventCERequest(): TopicEventCERequest {
  return {
    id: "",
    source: "",
    type: "",
    specVersion: "",
    dataContentType: "",
    data: new Uint8Array(0),
    extensions: undefined,
  };
}

export const TopicEventCERequest = {
  encode(message: TopicEventCERequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.specVersion !== "") {
      writer.uint32(34).string(message.specVersion);
    }
    if (message.dataContentType !== "") {
      writer.uint32(42).string(message.dataContentType);
    }
    if (message.data.length !== 0) {
      writer.uint32(50).bytes(message.data);
    }
    if (message.extensions !== undefined) {
      Struct.encode(Struct.wrap(message.extensions), writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventCERequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventCERequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.specVersion = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dataContentType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.extensions = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicEventCERequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      specVersion: isSet(object.specVersion) ? globalThis.String(object.specVersion) : "",
      dataContentType: isSet(object.dataContentType) ? globalThis.String(object.dataContentType) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      extensions: isObject(object.extensions) ? object.extensions : undefined,
    };
  },

  toJSON(message: TopicEventCERequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.specVersion !== "") {
      obj.specVersion = message.specVersion;
    }
    if (message.dataContentType !== "") {
      obj.dataContentType = message.dataContentType;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.extensions !== undefined) {
      obj.extensions = message.extensions;
    }
    return obj;
  },

  create(base?: DeepPartial<TopicEventCERequest>): TopicEventCERequest {
    return TopicEventCERequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicEventCERequest>): TopicEventCERequest {
    const message = createBaseTopicEventCERequest();
    message.id = object.id ?? "";
    message.source = object.source ?? "";
    message.type = object.type ?? "";
    message.specVersion = object.specVersion ?? "";
    message.dataContentType = object.dataContentType ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.extensions = object.extensions ?? undefined;
    return message;
  },
};

function createBaseTopicEventBulkRequestEntry(): TopicEventBulkRequestEntry {
  return { entryId: "", bytes: undefined, cloudEvent: undefined, contentType: "", metadata: {} };
}

export const TopicEventBulkRequestEntry = {
  encode(message: TopicEventBulkRequestEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entryId !== "") {
      writer.uint32(10).string(message.entryId);
    }
    if (message.bytes !== undefined) {
      writer.uint32(18).bytes(message.bytes);
    }
    if (message.cloudEvent !== undefined) {
      TopicEventCERequest.encode(message.cloudEvent, writer.uint32(26).fork()).ldelim();
    }
    if (message.contentType !== "") {
      writer.uint32(34).string(message.contentType);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      TopicEventBulkRequestEntry_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventBulkRequestEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventBulkRequestEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entryId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bytes = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cloudEvent = TopicEventCERequest.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = TopicEventBulkRequestEntry_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicEventBulkRequestEntry {
    return {
      entryId: isSet(object.entryId) ? globalThis.String(object.entryId) : "",
      bytes: isSet(object.bytes) ? bytesFromBase64(object.bytes) : undefined,
      cloudEvent: isSet(object.cloudEvent) ? TopicEventCERequest.fromJSON(object.cloudEvent) : undefined,
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TopicEventBulkRequestEntry): unknown {
    const obj: any = {};
    if (message.entryId !== "") {
      obj.entryId = message.entryId;
    }
    if (message.bytes !== undefined) {
      obj.bytes = base64FromBytes(message.bytes);
    }
    if (message.cloudEvent !== undefined) {
      obj.cloudEvent = TopicEventCERequest.toJSON(message.cloudEvent);
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<TopicEventBulkRequestEntry>): TopicEventBulkRequestEntry {
    return TopicEventBulkRequestEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicEventBulkRequestEntry>): TopicEventBulkRequestEntry {
    const message = createBaseTopicEventBulkRequestEntry();
    message.entryId = object.entryId ?? "";
    message.bytes = object.bytes ?? undefined;
    message.cloudEvent = (object.cloudEvent !== undefined && object.cloudEvent !== null)
      ? TopicEventCERequest.fromPartial(object.cloudEvent)
      : undefined;
    message.contentType = object.contentType ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseTopicEventBulkRequestEntry_MetadataEntry(): TopicEventBulkRequestEntry_MetadataEntry {
  return { key: "", value: "" };
}

export const TopicEventBulkRequestEntry_MetadataEntry = {
  encode(message: TopicEventBulkRequestEntry_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventBulkRequestEntry_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventBulkRequestEntry_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicEventBulkRequestEntry_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TopicEventBulkRequestEntry_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<TopicEventBulkRequestEntry_MetadataEntry>): TopicEventBulkRequestEntry_MetadataEntry {
    return TopicEventBulkRequestEntry_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicEventBulkRequestEntry_MetadataEntry>): TopicEventBulkRequestEntry_MetadataEntry {
    const message = createBaseTopicEventBulkRequestEntry_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTopicEventBulkRequest(): TopicEventBulkRequest {
  return { id: "", entries: [], metadata: {}, topic: "", pubsubName: "", type: "", path: "" };
}

export const TopicEventBulkRequest = {
  encode(message: TopicEventBulkRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.entries) {
      TopicEventBulkRequestEntry.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      TopicEventBulkRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.topic !== "") {
      writer.uint32(34).string(message.topic);
    }
    if (message.pubsubName !== "") {
      writer.uint32(42).string(message.pubsubName);
    }
    if (message.type !== "") {
      writer.uint32(50).string(message.type);
    }
    if (message.path !== "") {
      writer.uint32(58).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventBulkRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventBulkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entries.push(TopicEventBulkRequestEntry.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = TopicEventBulkRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pubsubName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.type = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicEventBulkRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => TopicEventBulkRequestEntry.fromJSON(e))
        : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      pubsubName: isSet(object.pubsubName) ? globalThis.String(object.pubsubName) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: TopicEventBulkRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => TopicEventBulkRequestEntry.toJSON(e));
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.pubsubName !== "") {
      obj.pubsubName = message.pubsubName;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<TopicEventBulkRequest>): TopicEventBulkRequest {
    return TopicEventBulkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicEventBulkRequest>): TopicEventBulkRequest {
    const message = createBaseTopicEventBulkRequest();
    message.id = object.id ?? "";
    message.entries = object.entries?.map((e) => TopicEventBulkRequestEntry.fromPartial(e)) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.topic = object.topic ?? "";
    message.pubsubName = object.pubsubName ?? "";
    message.type = object.type ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseTopicEventBulkRequest_MetadataEntry(): TopicEventBulkRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const TopicEventBulkRequest_MetadataEntry = {
  encode(message: TopicEventBulkRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventBulkRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventBulkRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicEventBulkRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TopicEventBulkRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<TopicEventBulkRequest_MetadataEntry>): TopicEventBulkRequest_MetadataEntry {
    return TopicEventBulkRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicEventBulkRequest_MetadataEntry>): TopicEventBulkRequest_MetadataEntry {
    const message = createBaseTopicEventBulkRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTopicEventBulkResponseEntry(): TopicEventBulkResponseEntry {
  return { entryId: "", status: 0 };
}

export const TopicEventBulkResponseEntry = {
  encode(message: TopicEventBulkResponseEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entryId !== "") {
      writer.uint32(10).string(message.entryId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventBulkResponseEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventBulkResponseEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entryId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicEventBulkResponseEntry {
    return {
      entryId: isSet(object.entryId) ? globalThis.String(object.entryId) : "",
      status: isSet(object.status) ? topicEventResponse_TopicEventResponseStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: TopicEventBulkResponseEntry): unknown {
    const obj: any = {};
    if (message.entryId !== "") {
      obj.entryId = message.entryId;
    }
    if (message.status !== 0) {
      obj.status = topicEventResponse_TopicEventResponseStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicEventBulkResponseEntry>): TopicEventBulkResponseEntry {
    return TopicEventBulkResponseEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicEventBulkResponseEntry>): TopicEventBulkResponseEntry {
    const message = createBaseTopicEventBulkResponseEntry();
    message.entryId = object.entryId ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseTopicEventBulkResponse(): TopicEventBulkResponse {
  return { statuses: [] };
}

export const TopicEventBulkResponse = {
  encode(message: TopicEventBulkResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.statuses) {
      TopicEventBulkResponseEntry.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicEventBulkResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicEventBulkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.statuses.push(TopicEventBulkResponseEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicEventBulkResponse {
    return {
      statuses: globalThis.Array.isArray(object?.statuses)
        ? object.statuses.map((e: any) => TopicEventBulkResponseEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TopicEventBulkResponse): unknown {
    const obj: any = {};
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => TopicEventBulkResponseEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TopicEventBulkResponse>): TopicEventBulkResponse {
    return TopicEventBulkResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicEventBulkResponse>): TopicEventBulkResponse {
    const message = createBaseTopicEventBulkResponse();
    message.statuses = object.statuses?.map((e) => TopicEventBulkResponseEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBindingEventRequest(): BindingEventRequest {
  return { name: "", data: new Uint8Array(0), metadata: {} };
}

export const BindingEventRequest = {
  encode(message: BindingEventRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      BindingEventRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BindingEventRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindingEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = BindingEventRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BindingEventRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BindingEventRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<BindingEventRequest>): BindingEventRequest {
    return BindingEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BindingEventRequest>): BindingEventRequest {
    const message = createBaseBindingEventRequest();
    message.name = object.name ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBindingEventRequest_MetadataEntry(): BindingEventRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const BindingEventRequest_MetadataEntry = {
  encode(message: BindingEventRequest_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BindingEventRequest_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindingEventRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BindingEventRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BindingEventRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BindingEventRequest_MetadataEntry>): BindingEventRequest_MetadataEntry {
    return BindingEventRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BindingEventRequest_MetadataEntry>): BindingEventRequest_MetadataEntry {
    const message = createBaseBindingEventRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBindingEventResponse(): BindingEventResponse {
  return { storeName: "", states: [], to: [], data: new Uint8Array(0), concurrency: 0 };
}

export const BindingEventResponse = {
  encode(message: BindingEventResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.storeName !== "") {
      writer.uint32(10).string(message.storeName);
    }
    for (const v of message.states) {
      StateItem.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.to) {
      writer.uint32(26).string(v!);
    }
    if (message.data.length !== 0) {
      writer.uint32(34).bytes(message.data);
    }
    if (message.concurrency !== 0) {
      writer.uint32(40).int32(message.concurrency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BindingEventResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBindingEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.storeName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.states.push(StateItem.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.to.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.concurrency = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BindingEventResponse {
    return {
      storeName: isSet(object.storeName) ? globalThis.String(object.storeName) : "",
      states: globalThis.Array.isArray(object?.states) ? object.states.map((e: any) => StateItem.fromJSON(e)) : [],
      to: globalThis.Array.isArray(object?.to) ? object.to.map((e: any) => globalThis.String(e)) : [],
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      concurrency: isSet(object.concurrency)
        ? bindingEventResponse_BindingEventConcurrencyFromJSON(object.concurrency)
        : 0,
    };
  },

  toJSON(message: BindingEventResponse): unknown {
    const obj: any = {};
    if (message.storeName !== "") {
      obj.storeName = message.storeName;
    }
    if (message.states?.length) {
      obj.states = message.states.map((e) => StateItem.toJSON(e));
    }
    if (message.to?.length) {
      obj.to = message.to;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.concurrency !== 0) {
      obj.concurrency = bindingEventResponse_BindingEventConcurrencyToJSON(message.concurrency);
    }
    return obj;
  },

  create(base?: DeepPartial<BindingEventResponse>): BindingEventResponse {
    return BindingEventResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BindingEventResponse>): BindingEventResponse {
    const message = createBaseBindingEventResponse();
    message.storeName = object.storeName ?? "";
    message.states = object.states?.map((e) => StateItem.fromPartial(e)) || [];
    message.to = object.to?.map((e) => e) || [];
    message.data = object.data ?? new Uint8Array(0);
    message.concurrency = object.concurrency ?? 0;
    return message;
  },
};

function createBaseListTopicSubscriptionsResponse(): ListTopicSubscriptionsResponse {
  return { subscriptions: [] };
}

export const ListTopicSubscriptionsResponse = {
  encode(message: ListTopicSubscriptionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.subscriptions) {
      TopicSubscription.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListTopicSubscriptionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopicSubscriptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriptions.push(TopicSubscription.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopicSubscriptionsResponse {
    return {
      subscriptions: globalThis.Array.isArray(object?.subscriptions)
        ? object.subscriptions.map((e: any) => TopicSubscription.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListTopicSubscriptionsResponse): unknown {
    const obj: any = {};
    if (message.subscriptions?.length) {
      obj.subscriptions = message.subscriptions.map((e) => TopicSubscription.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListTopicSubscriptionsResponse>): ListTopicSubscriptionsResponse {
    return ListTopicSubscriptionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTopicSubscriptionsResponse>): ListTopicSubscriptionsResponse {
    const message = createBaseListTopicSubscriptionsResponse();
    message.subscriptions = object.subscriptions?.map((e) => TopicSubscription.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTopicSubscription(): TopicSubscription {
  return { pubsubName: "", topic: "", metadata: {}, routes: undefined, deadLetterTopic: "", bulkSubscribe: undefined };
}

export const TopicSubscription = {
  encode(message: TopicSubscription, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pubsubName !== "") {
      writer.uint32(10).string(message.pubsubName);
    }
    if (message.topic !== "") {
      writer.uint32(18).string(message.topic);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      TopicSubscription_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.routes !== undefined) {
      TopicRoutes.encode(message.routes, writer.uint32(42).fork()).ldelim();
    }
    if (message.deadLetterTopic !== "") {
      writer.uint32(50).string(message.deadLetterTopic);
    }
    if (message.bulkSubscribe !== undefined) {
      BulkSubscribeConfig.encode(message.bulkSubscribe, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicSubscription {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pubsubName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = TopicSubscription_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.routes = TopicRoutes.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.deadLetterTopic = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.bulkSubscribe = BulkSubscribeConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicSubscription {
    return {
      pubsubName: isSet(object.pubsubName) ? globalThis.String(object.pubsubName) : "",
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      routes: isSet(object.routes) ? TopicRoutes.fromJSON(object.routes) : undefined,
      deadLetterTopic: isSet(object.deadLetterTopic) ? globalThis.String(object.deadLetterTopic) : "",
      bulkSubscribe: isSet(object.bulkSubscribe) ? BulkSubscribeConfig.fromJSON(object.bulkSubscribe) : undefined,
    };
  },

  toJSON(message: TopicSubscription): unknown {
    const obj: any = {};
    if (message.pubsubName !== "") {
      obj.pubsubName = message.pubsubName;
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.routes !== undefined) {
      obj.routes = TopicRoutes.toJSON(message.routes);
    }
    if (message.deadLetterTopic !== "") {
      obj.deadLetterTopic = message.deadLetterTopic;
    }
    if (message.bulkSubscribe !== undefined) {
      obj.bulkSubscribe = BulkSubscribeConfig.toJSON(message.bulkSubscribe);
    }
    return obj;
  },

  create(base?: DeepPartial<TopicSubscription>): TopicSubscription {
    return TopicSubscription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicSubscription>): TopicSubscription {
    const message = createBaseTopicSubscription();
    message.pubsubName = object.pubsubName ?? "";
    message.topic = object.topic ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.routes = (object.routes !== undefined && object.routes !== null)
      ? TopicRoutes.fromPartial(object.routes)
      : undefined;
    message.deadLetterTopic = object.deadLetterTopic ?? "";
    message.bulkSubscribe = (object.bulkSubscribe !== undefined && object.bulkSubscribe !== null)
      ? BulkSubscribeConfig.fromPartial(object.bulkSubscribe)
      : undefined;
    return message;
  },
};

function createBaseTopicSubscription_MetadataEntry(): TopicSubscription_MetadataEntry {
  return { key: "", value: "" };
}

export const TopicSubscription_MetadataEntry = {
  encode(message: TopicSubscription_MetadataEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicSubscription_MetadataEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicSubscription_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicSubscription_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TopicSubscription_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<TopicSubscription_MetadataEntry>): TopicSubscription_MetadataEntry {
    return TopicSubscription_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicSubscription_MetadataEntry>): TopicSubscription_MetadataEntry {
    const message = createBaseTopicSubscription_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTopicRoutes(): TopicRoutes {
  return { rules: [], default: "" };
}

export const TopicRoutes = {
  encode(message: TopicRoutes, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.rules) {
      TopicRule.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.default !== "") {
      writer.uint32(18).string(message.default);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicRoutes {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicRoutes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rules.push(TopicRule.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.default = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicRoutes {
    return {
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => TopicRule.fromJSON(e)) : [],
      default: isSet(object.default) ? globalThis.String(object.default) : "",
    };
  },

  toJSON(message: TopicRoutes): unknown {
    const obj: any = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => TopicRule.toJSON(e));
    }
    if (message.default !== "") {
      obj.default = message.default;
    }
    return obj;
  },

  create(base?: DeepPartial<TopicRoutes>): TopicRoutes {
    return TopicRoutes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicRoutes>): TopicRoutes {
    const message = createBaseTopicRoutes();
    message.rules = object.rules?.map((e) => TopicRule.fromPartial(e)) || [];
    message.default = object.default ?? "";
    return message;
  },
};

function createBaseTopicRule(): TopicRule {
  return { match: "", path: "" };
}

export const TopicRule = {
  encode(message: TopicRule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.match !== "") {
      writer.uint32(10).string(message.match);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TopicRule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopicRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.match = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TopicRule {
    return {
      match: isSet(object.match) ? globalThis.String(object.match) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: TopicRule): unknown {
    const obj: any = {};
    if (message.match !== "") {
      obj.match = message.match;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<TopicRule>): TopicRule {
    return TopicRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TopicRule>): TopicRule {
    const message = createBaseTopicRule();
    message.match = object.match ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseBulkSubscribeConfig(): BulkSubscribeConfig {
  return { enabled: false, maxMessagesCount: 0, maxAwaitDurationMs: 0 };
}

export const BulkSubscribeConfig = {
  encode(message: BulkSubscribeConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.maxMessagesCount !== 0) {
      writer.uint32(16).int32(message.maxMessagesCount);
    }
    if (message.maxAwaitDurationMs !== 0) {
      writer.uint32(24).int32(message.maxAwaitDurationMs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BulkSubscribeConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBulkSubscribeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxMessagesCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxAwaitDurationMs = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BulkSubscribeConfig {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      maxMessagesCount: isSet(object.maxMessagesCount) ? globalThis.Number(object.maxMessagesCount) : 0,
      maxAwaitDurationMs: isSet(object.maxAwaitDurationMs) ? globalThis.Number(object.maxAwaitDurationMs) : 0,
    };
  },

  toJSON(message: BulkSubscribeConfig): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.maxMessagesCount !== 0) {
      obj.maxMessagesCount = Math.round(message.maxMessagesCount);
    }
    if (message.maxAwaitDurationMs !== 0) {
      obj.maxAwaitDurationMs = Math.round(message.maxAwaitDurationMs);
    }
    return obj;
  },

  create(base?: DeepPartial<BulkSubscribeConfig>): BulkSubscribeConfig {
    return BulkSubscribeConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BulkSubscribeConfig>): BulkSubscribeConfig {
    const message = createBaseBulkSubscribeConfig();
    message.enabled = object.enabled ?? false;
    message.maxMessagesCount = object.maxMessagesCount ?? 0;
    message.maxAwaitDurationMs = object.maxAwaitDurationMs ?? 0;
    return message;
  },
};

function createBaseListInputBindingsResponse(): ListInputBindingsResponse {
  return { bindings: [] };
}

export const ListInputBindingsResponse = {
  encode(message: ListInputBindingsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.bindings) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListInputBindingsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInputBindingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bindings.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInputBindingsResponse {
    return {
      bindings: globalThis.Array.isArray(object?.bindings) ? object.bindings.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ListInputBindingsResponse): unknown {
    const obj: any = {};
    if (message.bindings?.length) {
      obj.bindings = message.bindings;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInputBindingsResponse>): ListInputBindingsResponse {
    return ListInputBindingsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInputBindingsResponse>): ListInputBindingsResponse {
    const message = createBaseListInputBindingsResponse();
    message.bindings = object.bindings?.map((e) => e) || [];
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return {};
}

export const HealthCheckResponse = {
  encode(_: HealthCheckResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HealthCheckResponse {
    return {};
  },

  toJSON(_: HealthCheckResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<HealthCheckResponse>): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<HealthCheckResponse>): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    return message;
  },
};

/**
 * AppCallback V1 allows user application to interact with Dapr runtime.
 * User application needs to implement AppCallback service if it needs to
 * receive message from dapr runtime.
 */
export type AppCallbackDefinition = typeof AppCallbackDefinition;
export const AppCallbackDefinition = {
  name: "AppCallback",
  fullName: "dapr.proto.runtime.v1.AppCallback",
  methods: {
    /** Invokes service method with InvokeRequest. */
    onInvoke: {
      name: "OnInvoke",
      requestType: InvokeRequest,
      requestStream: false,
      responseType: InvokeResponse,
      responseStream: false,
      options: {},
    },
    /** Lists all topics subscribed by this app. */
    listTopicSubscriptions: {
      name: "ListTopicSubscriptions",
      requestType: Empty,
      requestStream: false,
      responseType: ListTopicSubscriptionsResponse,
      responseStream: false,
      options: {},
    },
    /** Subscribes events from Pubsub */
    onTopicEvent: {
      name: "OnTopicEvent",
      requestType: TopicEventRequest,
      requestStream: false,
      responseType: TopicEventResponse,
      responseStream: false,
      options: {},
    },
    /** Lists all input bindings subscribed by this app. */
    listInputBindings: {
      name: "ListInputBindings",
      requestType: Empty,
      requestStream: false,
      responseType: ListInputBindingsResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Listens events from the input bindings
     *
     * User application can save the states or send the events to the output
     * bindings optionally by returning BindingEventResponse.
     */
    onBindingEvent: {
      name: "OnBindingEvent",
      requestType: BindingEventRequest,
      requestStream: false,
      responseType: BindingEventResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface AppCallbackServiceImplementation<CallContextExt = {}> {
  /** Invokes service method with InvokeRequest. */
  onInvoke(request: InvokeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<InvokeResponse>>;
  /** Lists all topics subscribed by this app. */
  listTopicSubscriptions(
    request: Empty,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTopicSubscriptionsResponse>>;
  /** Subscribes events from Pubsub */
  onTopicEvent(
    request: TopicEventRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TopicEventResponse>>;
  /** Lists all input bindings subscribed by this app. */
  listInputBindings(
    request: Empty,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListInputBindingsResponse>>;
  /**
   * Listens events from the input bindings
   *
   * User application can save the states or send the events to the output
   * bindings optionally by returning BindingEventResponse.
   */
  onBindingEvent(
    request: BindingEventRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BindingEventResponse>>;
}

export interface AppCallbackClient<CallOptionsExt = {}> {
  /** Invokes service method with InvokeRequest. */
  onInvoke(request: DeepPartial<InvokeRequest>, options?: CallOptions & CallOptionsExt): Promise<InvokeResponse>;
  /** Lists all topics subscribed by this app. */
  listTopicSubscriptions(
    request: DeepPartial<Empty>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTopicSubscriptionsResponse>;
  /** Subscribes events from Pubsub */
  onTopicEvent(
    request: DeepPartial<TopicEventRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TopicEventResponse>;
  /** Lists all input bindings subscribed by this app. */
  listInputBindings(
    request: DeepPartial<Empty>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListInputBindingsResponse>;
  /**
   * Listens events from the input bindings
   *
   * User application can save the states or send the events to the output
   * bindings optionally by returning BindingEventResponse.
   */
  onBindingEvent(
    request: DeepPartial<BindingEventRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BindingEventResponse>;
}

/**
 * AppCallbackHealthCheck V1 is an optional extension to AppCallback V1 to implement
 * the HealthCheck method.
 */
export type AppCallbackHealthCheckDefinition = typeof AppCallbackHealthCheckDefinition;
export const AppCallbackHealthCheckDefinition = {
  name: "AppCallbackHealthCheck",
  fullName: "dapr.proto.runtime.v1.AppCallbackHealthCheck",
  methods: {
    /** Health check. */
    healthCheck: {
      name: "HealthCheck",
      requestType: Empty,
      requestStream: false,
      responseType: HealthCheckResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface AppCallbackHealthCheckServiceImplementation<CallContextExt = {}> {
  /** Health check. */
  healthCheck(request: Empty, context: CallContext & CallContextExt): Promise<DeepPartial<HealthCheckResponse>>;
}

export interface AppCallbackHealthCheckClient<CallOptionsExt = {}> {
  /** Health check. */
  healthCheck(request: DeepPartial<Empty>, options?: CallOptions & CallOptionsExt): Promise<HealthCheckResponse>;
}

/**
 * AppCallbackAlpha V1 is an optional extension to AppCallback V1 to opt
 * for Alpha RPCs.
 */
export type AppCallbackAlphaDefinition = typeof AppCallbackAlphaDefinition;
export const AppCallbackAlphaDefinition = {
  name: "AppCallbackAlpha",
  fullName: "dapr.proto.runtime.v1.AppCallbackAlpha",
  methods: {
    /** Subscribes bulk events from Pubsub */
    onBulkTopicEventAlpha1: {
      name: "OnBulkTopicEventAlpha1",
      requestType: TopicEventBulkRequest,
      requestStream: false,
      responseType: TopicEventBulkResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface AppCallbackAlphaServiceImplementation<CallContextExt = {}> {
  /** Subscribes bulk events from Pubsub */
  onBulkTopicEventAlpha1(
    request: TopicEventBulkRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TopicEventBulkResponse>>;
}

export interface AppCallbackAlphaClient<CallOptionsExt = {}> {
  /** Subscribes bulk events from Pubsub */
  onBulkTopicEventAlpha1(
    request: DeepPartial<TopicEventBulkRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TopicEventBulkResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
